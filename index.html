<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carnet de R√©coltes Mycologiques</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --mushroom-brown-light: #D2B48C;
            --mushroom-brown: #8B4513;
            --mushroom-brown-dark: #654321;
            --mushroom-cream: #F5F5DC;
            --mushroom-white: #FAEBD7;
        }

        

        body {
            background: linear-gradient(135deg, var(--mushroom-cream) 0%, var(--mushroom-white) 100%);
            background-attachment: fixed;
            position: relative;
            min-height: 100vh;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 15% 20%, rgba(139, 69, 19, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 85% 80%, rgba(139, 69, 19, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 40% 60%, rgba(139, 69, 19, 0.025) 0%, transparent 60%);
            pointer-events: none;
            z-index: -1;
        }

        .mushroom-bg {
            background: linear-gradient(135deg, var(--mushroom-brown-light) 0%, var(--mushroom-brown) 100%);
        }

        .mushroom-card {
            background: rgba(245, 245, 220, 0.9);
            border: 2px solid var(--mushroom-brown-light);
            backdrop-filter: blur(10px);
        }

        

        .mushroom-btn {
            background: linear-gradient(135deg, var(--mushroom-brown) 0%, var(--mushroom-brown-dark) 100%);
            color: var(--mushroom-white);
            border: 1px solid var(--mushroom-brown-light);
            transition: all 0.3s ease;
        }

        .mushroom-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(139, 69, 19, 0.3);
        }

        .calendar-cell {
            min-height: 80px;
            border: 1px solid var(--mushroom-brown-light);
            position: relative;
        }

        .calendar-cell:hover {
            background: rgba(139, 69, 19, 0.1);
        }

        .weather-icon {
            font-size: 16px;
            position: absolute;
            top: 2px;
            right: 2px;
        }

        .mushroom-icon {
            font-size: 16px;
            position: absolute;
            bottom: 2px;
            left: 2px;
            color: var(--mushroom-brown);
        }

        /* Styles pour le nouveau calendrier multi-mois */
        .month-card {
            background: rgba(245, 245, 220, 0.9);
            border: 2px solid var(--mushroom-brown-light);
            border-radius: 10px;
            padding: 1rem;
            position: relative;
        }

        

        .month-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--mushroom-brown-light);
        }

        .month-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: var(--mushroom-brown);
        }



        .month-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
        }

        .day-header {
            text-align: center;
            font-weight: bold;
            padding: 0.5rem 0;
            color: var(--mushroom-brown);
            font-size: 0.875rem;
        }

        .day-cell {
            aspect-ratio: 1;
            border: 1px solid var(--mushroom-brown-light);
            padding: 0.25rem;
            cursor: pointer;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 40px;
            background: rgba(255, 255, 255, 0.5);
            transition: all 0.2s;
        }

        

        .day-cell:hover {
            background: rgba(139, 69, 19, 0.1);
        }

        .day-cell.other-month {
            opacity: 0.3;
            background: rgba(200, 200, 200, 0.3);
        }

        .day-cell.weather-only {
            background: rgba(135, 206, 250, 0.1);
            border-color: rgba(135, 206, 250, 0.5);
        }

        .day-cell.harvest-only {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .day-cell.has-both {
            background: rgba(50, 205, 50, 0.1);
            border-color: rgba(50, 205, 50, 0.5);
        }

        .day-number {
            font-size: 0.875rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .day-icons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            width: 100%;
            height: 100%;
            padding-bottom: 24px; /* Espace pour les temp√©ratures */
        }

        .day-weather {
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .day-weather:hover {
            transform: scale(1.2);
        }

        /* Ic√¥nes m√©t√©o plus grandes quand il n'y a que de la m√©t√©o */
        .weather-only .day-weather {
            font-size: 2rem;
        }

        .weather-only .day-weather:hover {
            transform: scale(1.3);
        }

        .day-harvest {
            font-size: 1rem;
            color: var(--mushroom-brown);
            cursor: pointer;
            transition: all 0.2s;
        }

        .day-harvest:hover {
            transform: scale(1.2);
        }

        .weather-palette {
            position: sticky;
            top: 1rem;
            z-index: 10;
        }

        .weather-btn {
            transition: all 0.2s;
            border: 1px solid transparent;
            font-size: 1.5rem;
            padding: 0.5rem;
        }

        .weather-btn:hover {
            border-color: var(--mushroom-brown-light);
            transform: scale(1.1);
        }

        .weather-btn.active {
            background: var(--mushroom-brown-light) !important;
            border-color: var(--mushroom-brown) !important;
            color: var(--mushroom-white) !important;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .month-card {
                margin-bottom: 1rem;
            }
            
            .day-cell {
                min-height: 35px;
                font-size: 0.75rem;
            }
            
            .day-weather, .day-harvest {
                font-size: 0.875rem;
            }
        }

        /* Animation pour l'effet de pulsation */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Styles pour les options de mois dans le modal */
        .month-option {
            transition: all 0.2s;
            border-radius: 4px;
        }

        .month-option:hover:not([disabled]) {
            background: var(--mushroom-brown-light);
            color: var(--mushroom-white);
        }

        .month-option:active:not([disabled]) {
            transform: scale(0.98);
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

                 .photo-upload {
             width: 220px;
             height: 165px;
             border: 2px dashed var(--mushroom-brown-light);
             display: flex;
             align-items: center;
             justify-content: center;
             cursor: pointer;
             transition: all 0.3s ease;
             background: rgba(245, 245, 220, 0.5);
         }

        .photo-upload:hover {
            border-color: var(--mushroom-brown);
            background: rgba(245, 245, 220, 0.7);
        }

        .photo-date-badge {
            position: absolute;
            right: 6px;
            bottom: 6px;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            font-size: 0.75rem;
            line-height: 1;
            padding: 4px 6px;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background: var(--mushroom-cream);
            margin: 5% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        

        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .nav-btn.active {
            background: var(--mushroom-brown);
            color: var(--mushroom-white);
        }

        

        table {
            background: rgba(245, 245, 220, 0.9);
        }

        

        th {
            background: var(--mushroom-brown);
            color: var(--mushroom-white);
            cursor: pointer;
        }

        th:hover {
            background: var(--mushroom-brown-dark);
        }

        tr:nth-child(even) {
            background: rgba(139, 69, 19, 0.05);
        }

        

        @media print {
            body {
                background: white !important;
            }
            
            body::before {
                display: none !important;
            }
            
            .no-print {
                display: none !important;
            }
            
            .print-hide {
                display: none !important;
            }
            
            .print-area {
                display: block !important;
            }
            
            .modal {
                position: static !important;
                background: white !important;
            }
            
            .modal-content {
                box-shadow: none !important;
                border: 1px solid #ccc !important;
            }
        }

        /* Styles pour les temp√©ratures */
        .temperature-btn {
            transition: all 0.2s;
            border: 1px solid transparent;
            font-size: 0.875rem;
            padding: 0.5rem;
            margin: 0 0.25rem;
        }

        .temperature-btn:hover {
            border-color: var(--mushroom-brown-light);
            transform: scale(1.05);
        }

        .temperature-btn.active {
            background: var(--mushroom-brown-light) !important;
            border-color: var(--mushroom-brown) !important;
            color: var(--mushroom-white) !important;
        }

        .temperature-display {
            position: absolute;
            font-size: 0.75rem;
            font-weight: bold;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .temperature-mini {
            bottom: 2px;
            left: 2px;
        }

        .temperature-maxi {
            bottom: 2px;
            right: 2px;
        }

        .temperature-blue {
            background: #3B82F6;
        }

        .temperature-green {
            background: #10B981;
        }

        .temperature-orange {
            background: #FB923C;
        }

        .temperature-red {
            background: #EF4444;
        }

        .temperature-input {
            width: 60px;
            text-align: center;
            font-size: 0.875rem;
        }

        .weight-display {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--mushroom-brown);
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 4px;
            border-radius: 8px;
            border: 1px solid var(--mushroom-brown-light);
            text-shadow: none;
            z-index: 2;
        }

        
    </style>
</head>
<body class="font-sans">
    <!-- Header -->
    <header class="mushroom-bg shadow-lg p-4">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold text-white flex items-center">
                <i class="fas fa-seedling mr-3"></i>
                Carnet de R√©coltes Mycologiques
            </h1>
            
            <nav class="flex items-center space-x-4">
                <button class="nav-btn mushroom-btn px-4 py-2 rounded active" onclick="showPage('dashboard')">
                    <i class="fas fa-home mr-2"></i>Tableau de Bord
                </button>
                <button class="nav-btn mushroom-btn px-4 py-2 rounded" onclick="showPage('calendar')">
                    <i class="fas fa-calendar-alt mr-2"></i>Calendrier
                </button>
                <button class="nav-btn mushroom-btn px-4 py-2 rounded" onclick="showPage('harvests')">
                    <i class="fas fa-table mr-2"></i>R√©coltes
                </button>
                <button class="nav-btn mushroom-btn px-4 py-2 rounded" onclick="showPage('settings')">
                    <i class="fas fa-cog mr-2"></i>R√©glages
                </button>
            </nav>
        </div>
    </header>

    <!-- Dashboard Page -->
    <div id="dashboard" class="page active p-6">
        <div class="container mx-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold" style="color: var(--mushroom-brown);">
                                         <i class="fas fa-chart-line mr-3"></i>Tableau de Bord - Ann√©e <span id="currentYear"></span>
                </h2>
                
                <div class="flex items-center space-x-2">
                                         <select id="yearSelector" class="mushroom-btn px-4 py-2 rounded" onchange="changeYear()">
                     </select>
                    <button class="mushroom-btn px-4 py-2 rounded" onclick="addNewYear()">
                        <i class="fas fa-plus mr-2"></i>Nouvelle Ann√©e
                    </button>
                </div>
            </div>

                         <!-- Photo Gallery -->
             <div class="mushroom-card rounded-lg p-6 mb-2">
                <h3 class="text-xl font-bold mb-4" style="color: var(--mushroom-brown);">
                    <i class="fas fa-images mr-2"></i>Galerie Photos Favorites <span class="text-sm font-normal">(Ann√©e <span id="currentYearPhotos"></span>)</span>
                </h3>
                                 <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-2">
                    <div class="photo-upload rounded-lg relative" onclick="uploadDashboardPhoto(0)">
                        <div id="dashPhoto0" class="w-full h-full flex items-center justify-center">
                            <i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>
                        </div>
                        <button id="removePhoto0" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs opacity-0 hover:opacity-100 transition-opacity duration-200" 
                                onclick="removeDashboardPhoto(0); event.stopPropagation();" title="Supprimer">√ó</button>
                    </div>
                    <div class="photo-upload rounded-lg relative" onclick="uploadDashboardPhoto(1)">
                        <div id="dashPhoto1" class="w-full h-full flex items-center justify-center">
                            <i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>
                        </div>
                        <button id="removePhoto1" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs opacity-0 hover:opacity-100 transition-opacity duration-200" 
                                onclick="removeDashboardPhoto(1); event.stopPropagation();" title="Supprimer">√ó</button>
                    </div>
                    <div class="photo-upload rounded-lg relative" onclick="uploadDashboardPhoto(2)">
                        <div id="dashPhoto2" class="w-full h-full flex items-center justify-center">
                            <i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>
                        </div>
                        <button id="removePhoto2" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs opacity-0 hover:opacity-100 transition-opacity duration-200" 
                                onclick="removeDashboardPhoto(2); event.stopPropagation();" title="Supprimer">√ó</button>
                    </div>
                    <div class="photo-upload rounded-lg relative" onclick="uploadDashboardPhoto(3)">
                        <div id="dashPhoto3" class="w-full h-full flex items-center justify-center">
                            <i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>
                        </div>
                        <button id="removePhoto3" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs opacity-0 hover:opacity-100 transition-opacity duration-200" 
                                onclick="removeDashboardPhoto(3); event.stopPropagation();" title="Supprimer">√ó</button>
                    </div>
                    <div class="photo-upload rounded-lg relative" onclick="uploadDashboardPhoto(4)">
                        <div id="dashPhoto4" class="w-full h-full flex items-center justify-center">
                            <i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>
                        </div>
                        <button id="removePhoto4" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs opacity-0 hover:opacity-100 transition-opacity duration-200" 
                                onclick="removeDashboardPhoto(4); event.stopPropagation();" title="Supprimer">√ó</button>
                    </div>
                    
                </div>
            </div>

                         <!-- Statistics Cards -->
             <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-2">
                <div class="mushroom-card rounded-lg p-6 text-center">
                    <i class="fas fa-weight text-3xl mb-2" style="color: var(--mushroom-brown);"></i>
                    <h4 class="font-bold" style="color: var(--mushroom-brown);">R√©colte Totale</h4>
                    <p class="text-2xl font-bold" id="totalWeight">0 kg</p>
                </div>
                <div class="mushroom-card rounded-lg p-6 text-center">
                    <i class="fas fa-calendar-check text-3xl mb-2" style="color: var(--mushroom-brown);"></i>
                    <h4 class="font-bold" style="color: var(--mushroom-brown);">Sorties</h4>
                    <p class="text-2xl font-bold" id="totalOutings">0</p>
                </div>
                <div class="mushroom-card rounded-lg p-6 text-center">
                    <i class="fas fa-seedling text-3xl mb-2" style="color: var(--mushroom-brown);"></i>
                    <h4 class="font-bold" style="color: var(--mushroom-brown);">Vari√©t√©s</h4>
                    <p class="text-2xl font-bold" id="totalVarieties">0</p>
                </div>
                <div class="mushroom-card rounded-lg p-6 text-center">
                    <i class="fas fa-trophy text-3xl mb-2" style="color: var(--mushroom-brown);"></i>
                    <h4 class="font-bold" style="color: var(--mushroom-brown);">Meilleure R√©colte</h4>
                    <p class="text-2xl font-bold" id="bestHarvest">0 kg</p>
                </div>
            </div>

                         <!-- Charts -->
             <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                   <div class="mushroom-card rounded-lg p-6" id="weeklyChartContainer" style="cursor: pointer;">
                      <h3 class="text-xl font-bold mb-4 text-center" style="color: var(--mushroom-brown);">
                          <i class="fas fa-chart-bar mr-2"></i>R√©coltes par Jours
                      </h3>
                     <div class="chart-container">
                         <canvas id="weeklyChart"></canvas>
                     </div>
                 </div>
                 
                                   <div class="mushroom-card rounded-lg p-6" id="varietyChartContainer" style="cursor: pointer;">
                      <h3 class="text-xl font-bold mb-4 text-center" style="color: var(--mushroom-brown);">
                          <i class="fas fa-chart-pie mr-2"></i>R√©partition par Vari√©t√©s
                      </h3>
                     <div class="chart-container">
                         <canvas id="varietyChart"></canvas>
                     </div>
                 </div>
                 
                                   <div class="mushroom-card rounded-lg p-6" id="distanceChartContainer" style="cursor: pointer;">
                                       <h3 class="text-xl font-bold mb-4 text-center" style="color: var(--mushroom-brown);">
                      <i class="fas fa-route mr-2"></i>Distances parcourues
                  </h3>
                     <div class="chart-container">
                         <canvas id="distanceChart"></canvas>
                     </div>
                 </div>
             </div>
        </div>
    </div>

    <!-- Calendar Page -->
    <div id="calendar" class="page p-6">
        <div class="container mx-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold" style="color: var(--mushroom-brown);">
                    <i class="fas fa-calendar-alt mr-3"></i>Calendrier des R√©coltes - Ann√©e <span id="currentYearCalendar"></span>
                </h2>
                
                <div class="flex items-center space-x-2">
                    <select id="yearSelectorCalendar" class="mushroom-btn px-4 py-2 rounded" onchange="changeYearFromCalendar()">
                    </select>
                    <button class="mushroom-btn px-4 py-2 rounded" onclick="addNewYear()">
                        <i class="fas fa-plus mr-2"></i>Nouvelle Ann√©e
                    </button>
                </div>
            </div>
            
            <!-- Contr√¥les pour ajouter des mois -->
            <div class="mushroom-card rounded-lg p-6 mb-6">
                <div class="flex flex-wrap items-center justify-between gap-4">
                    <div class="flex items-center space-x-4">
                        <button class="mushroom-btn px-4 py-2 rounded" onclick="addMonth()">
                            <i class="fas fa-plus mr-2"></i>Ajouter un mois
                        </button>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <!-- Palette m√©t√©o flottante -->
                        <div class="weather-palette bg-white border rounded-lg p-3 shadow-lg">
                            <h4 class="font-bold mb-2 text-sm" style="color: var(--mushroom-brown);">M√©t√©o √† Golfe Juan et potentiellement arri√®re pays</h4>
                            <div class="flex space-x-2">
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="sunny" title="Ensoleill√©">
                                    ‚òÄÔ∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="cloud_sun" title="Nuage + Soleil">
                                    ‚õÖ
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="cloudy" title="Nuageux">
                                    ‚òÅÔ∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="rainy" title="Pluvieux">
                                    üåßÔ∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="thunderstorm" title="Orage">
                                    ‚õàÔ∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="tornado" title="Tornade">
                                    üå™Ô∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="foggy" title="Brouillard">
                                    üå´Ô∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="snowy" title="Neige">
                                    üå®Ô∏è
                                </button>
                                <button class="weather-btn p-2 rounded hover:bg-gray-100" data-weather="lightning" title="√âclair">
                                    ‚ö°
                                </button>
                            </div>
                        </div>

                        <!-- Palette temp√©ratures -->
                        <div class="bg-white border rounded-lg p-3 shadow-lg">
                            <h4 class="font-bold mb-2 text-sm" style="color: var(--mushroom-brown);">Temp√©ratures</h4>
                            <div class="flex items-center space-x-2">
                                <input type="number" id="temperatureInput" class="temperature-input px-2 py-1 border rounded" placeholder="¬∞C" min="-20" max="50">
                                <button class="temperature-btn mushroom-btn px-3 py-1 rounded" id="tempMiniBtn" onclick="selectTemperatureType('mini')">
                                    Mini
                                </button>
                                <button class="temperature-btn mushroom-btn px-3 py-1 rounded" id="tempMaxiBtn" onclick="selectTemperatureType('maxi')">
                                    Maxi
                                </button>
                            </div>
                                                    <div class="text-xs text-gray-600 mt-1">
                            <span class="inline-block w-3 h-3 bg-blue-500 rounded-full mr-1"></span>0-10¬∞C
                            <span class="inline-block w-3 h-3 bg-green-500 rounded-full mr-1 ml-2"></span>11-17¬∞C
                            <span class="inline-block w-3 h-3 bg-orange-400 rounded-full mr-1 ml-2"></span>18-24¬∞C
                            <span class="inline-block w-3 h-3 bg-red-500 rounded-full mr-1 ml-2"></span>25¬∞C+
                        </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Grille des mois -->
            <div id="monthsGrid" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Les mois seront g√©n√©r√©s ici par JavaScript -->
            </div>
        </div>
    </div>

    <!-- Harvests Table Page -->
    <div id="harvests" class="page p-6">
        <div class="container mx-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-3xl font-bold" style="color: var(--mushroom-brown);">
                    <i class="fas fa-table mr-3"></i>D√©tail des R√©coltes - Ann√©e <span id="currentYearHarvests"></span>
                </h2>
                
                <div class="flex items-center space-x-2">
                    <select id="yearSelectorHarvests" class="mushroom-btn px-4 py-2 rounded" onchange="changeYearFromHarvests()">
                    </select>
                    <button class="mushroom-btn px-4 py-2 rounded" onclick="addNewYear()">
                        <i class="fas fa-plus mr-2"></i>Nouvelle Ann√©e
                    </button>
                </div>
            </div>
            
            <div class="mushroom-card rounded-lg p-6">
                <div class="flex justify-between items-center mb-6">
                    <button class="mushroom-btn px-4 py-2 rounded" onclick="addNewHarvest()">
                        <i class="fas fa-plus mr-2"></i>Nouvelle R√©colte
                    </button>
                    <div class="flex space-x-2">
                        <input type="text" id="searchHarvests" placeholder="Rechercher..." 
                               class="px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);" 
                               onkeyup="filterHarvests()">
                        <button class="mushroom-btn px-4 py-2 rounded" onclick="exportHarvestsJSON()">
                            <i class="fas fa-download mr-2"></i>Export JSON
                        </button>
                    </div>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="w-full border-collapse rounded-lg overflow-hidden">
                        <thead>
                            <tr>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('photo')">
                                    <i class="fas fa-camera mr-2"></i>Photo
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('date')">
                                    <i class="fas fa-calendar mr-2"></i>Date <i class="fas fa-sort"></i>
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('time')">
                                    <i class="fas fa-clock mr-2"></i>Heure <i class="fas fa-sort"></i>
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('variety')">
                                    <i class="fas fa-seedling mr-2"></i>Vari√©t√© <i class="fas fa-sort"></i>
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('weight')">
                                    <i class="fas fa-weight mr-2"></i>Poids <i class="fas fa-sort"></i>
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('location')">
                                    <i class="fas fa-map-marker-alt mr-2"></i>Emplacement <i class="fas fa-sort"></i>
                                </th>
                                <th class="p-3 text-left cursor-pointer" onclick="sortTable('duration')">
                                    <i class="fas fa-hourglass-half mr-2"></i>Dur√©e <i class="fas fa-sort"></i>
                                </th>
                                                                 <th class="p-3 text-left cursor-pointer" onclick="sortTable('distance')">
                                     <i class="fas fa-route mr-2"></i>Distances <i class="fas fa-sort"></i>
                                 </th>
                                <th class="p-3 text-left">
                                    <i class="fas fa-comment mr-2"></i>Commentaires
                                </th>
                                <th class="p-3 text-left">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="harvestsTableBody">
                            <!-- Table content will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Page -->
    <div id="settings" class="page p-6">
        <div class="container mx-auto">
            <h2 class="text-3xl font-bold mb-6 text-center" style="color: var(--mushroom-brown);">
                <i class="fas fa-cog mr-3"></i>R√©glages
            </h2>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Vari√©t√©s pr√©d√©finies -->
                <div class="mushroom-card rounded-lg p-6">
                    <h3 class="text-xl font-bold mb-4" style="color: var(--mushroom-brown);">
                        <i class="fas fa-list mr-2"></i>Vari√©t√©s Pr√©d√©finies
                    </h3>
                    <div class="space-y-2 mb-4" id="varietiesList">
                        <!-- Varieties will be populated by JavaScript -->
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="newVariety" placeholder="Nouvelle vari√©t√©..." 
                               class="flex-1 px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);">
                        <button class="mushroom-btn px-4 py-2 rounded" onclick="addVariety()">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>

                <!-- Emplacements pr√©d√©finis -->
                <div class="mushroom-card rounded-lg p-6">
                    <h3 class="text-xl font-bold mb-4" style="color: var(--mushroom-brown);">
                        <i class="fas fa-map-marker-alt mr-2"></i>Emplacements Pr√©d√©finis
                    </h3>
                    <div class="space-y-2 mb-4" id="locationsList">
                        <!-- Locations will be populated by JavaScript -->
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="newLocation" placeholder="Nouvel emplacement..." 
                               class="flex-1 px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);">
                        <button class="mushroom-btn px-4 py-2 rounded" onclick="addLocation()">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>

                <!-- Pr√©f√©rences -->
                <div class="mushroom-card rounded-lg p-6">
                    <h3 class="text-xl font-bold mb-4" style="color: var(--mushroom-brown);">
                        <i class="fas fa-user-cog mr-2"></i>Pr√©f√©rences
                    </h3>
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <label class="font-medium">Unit√© de poids par d√©faut</label>
                            <select id="defaultWeightUnit" class="px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);">
                                <option value="kg">Kilogrammes (kg)</option>
                                <option value="g">Grammes (g)</option>
                            </select>
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="font-medium">Format de date</label>
                            <select id="dateFormat" class="px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);">
                                <option value="DD/MM/YYYY">DD/MM/YYYY</option>
                                <option value="MM/DD/YYYY">MM/DD/YYYY</option>
                                <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                            </select>
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="font-medium">Taille maximale des photos (Ko)</label>
                            <select id="maxPhotoSize" class="px-3 py-2 border rounded" style="border-color: var(--mushroom-brown-light);">
                                <option value="15">15 Ko (miniatures)</option>
                                <option value="40">40 Ko (tableau de bord)</option>
                                <option value="100">100 Ko (haute qualit√©)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Import/Export -->
                <div class="mushroom-card rounded-lg p-6">
                    <h3 class="text-xl font-bold mb-4" style="color: var(--mushroom-brown);">
                        <i class="fas fa-exchange-alt mr-2"></i>Import/Export
                    </h3>
                    <div class="space-y-4">
                        <div>
                            <label class="block font-medium mb-2">Importer des donn√©es</label>
                            <input type="file" id="importFile" accept=".json" class="hidden">
                            <button class="mushroom-btn px-4 py-2 rounded" onclick="triggerImport()">
                                <i class="fas fa-upload mr-2"></i>Importer
                            </button>
                        </div>
                        <div>
                            <label class="block font-medium mb-2">Exporter toutes les donn√©es</label>
                            <button class="mushroom-btn px-4 py-2 rounded" onclick="exportAllData()">
                                <i class="fas fa-download mr-2"></i>Exporter JSON
                            </button>
                        </div>
                        <div>
                            <label class="block font-medium mb-2">R√©initialiser toutes les donn√©es</label>
                            <button class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded transition-colors" onclick="resetAllData()">
                                <i class="fas fa-trash-alt mr-2"></i>R√©initialiser
                            </button>
                        </div>
                        <div>
                            <label class="block font-medium mb-2">Sauvegarde automatique</label>
                            <div class="flex items-center space-x-2">
                                <input type="checkbox" id="autoBackup" class="mr-2">
                                <span>Cr√©er une sauvegarde automatique chaque semaine</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for Harvest Details -->
    <div id="harvestModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold" style="color: var(--mushroom-brown);">
                    <i class="fas fa-seedling mr-2"></i>D√©tails de la R√©colte
                </h3>
                <button class="text-2xl" onclick="closeModal('harvestModal')">&times;</button>
            </div>
            
            <form id="harvestForm" class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block font-medium mb-1">Date *</label>
                        <input type="date" id="harvestDate" required class="w-full px-3 py-2 border rounded">
                    </div>
                    <div>
                        <label class="block font-medium mb-1">Heure d'arriv√©e</label>
                        <input type="time" id="harvestTime" class="w-full px-3 py-2 border rounded">
                    </div>
                    <div>
                        <label class="block font-medium mb-1">Vari√©t√© *</label>
                        <select id="harvestVariety" class="w-full px-3 py-2 border rounded">
                            <option value="">S√©lectionner...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block font-medium mb-1">Poids (kg) *</label>
                        <input type="number" step="0.001" id="harvestWeight" required class="w-full px-3 py-2 border rounded" placeholder="ex: 5.2 ou 0.400">
                    </div>
                    <div>
                        <label class="block font-medium mb-1">Emplacement</label>
                        <select id="harvestLocation" class="w-full px-3 py-2 border rounded">
                            <option value="">S√©lectionner...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block font-medium mb-1">Dur√©e (heures)</label>
                        <input type="number" step="0.25" id="harvestDuration" class="w-full px-3 py-2 border rounded" placeholder="ex: 2.5">
                    </div>
                                         <div>
                         <label class="block font-medium mb-1">Distance parcourue (km)</label>
                         <div class="grid grid-cols-2 gap-2">
                             <div>
                                 <label class="block text-sm mb-1">Misu</label>
                                 <input type="number" step="0.1" id="harvestDistanceMisu" class="w-full px-3 py-2 border rounded" placeholder="ex: 3.4">
                             </div>
                             <div>
                                 <label class="block text-sm mb-1">Misa</label>
                                 <input type="number" step="0.1" id="harvestDistanceMisa" class="w-full px-3 py-2 border rounded" placeholder="ex: 2.8">
                             </div>
                         </div>
                     </div>
                    <div>
                        <label class="block font-medium mb-1">M√©t√©o</label>
                        <select id="harvestWeather" class="w-full px-3 py-2 border rounded">
                            <option value="">S√©lectionner...</option>
                            <option value="sunny">‚òÄÔ∏è Ensoleill√©</option>
                            <option value="cloudy">‚òÅÔ∏è Nuageux</option>
                            <option value="rainy">üåßÔ∏è Pluvieux</option>
                            <option value="thunderstorm">‚õàÔ∏è Orage</option>
                            <option value="tornado">üå™Ô∏è Tornade</option>
                            <option value="foggy">üå´Ô∏è Brouillard</option>
                            <option value="windy">üí® Venteux</option>
                        </select>
                    </div>
                </div>
                
                <div>
                    <label class="block font-medium mb-1">Photos</label>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-2" id="harvestPhotos">
                        <!-- Photos will be populated here -->
                    </div>
                    <input type="file" id="addHarvestPhoto" accept="image/*" multiple class="w-full" onchange="handleHarvestPhotoUpload(event)">
                </div>
                
                <div>
                    <label class="block font-medium mb-1">Commentaires</label>
                    <textarea id="harvestComments" rows="3" class="w-full px-3 py-2 border rounded" placeholder="Observations, conditions, etc..."></textarea>
                </div>
                
                <div class="flex justify-end space-x-4">
                    <button type="button" class="px-4 py-2 border rounded" onclick="closeModal('harvestModal')">Annuler</button>
                    <button type="submit" class="mushroom-btn px-4 py-2 rounded">
                        <i class="fas fa-save mr-2"></i>Enregistrer
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal for Calendar Day Details -->
    <div id="dayModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold" style="color: var(--mushroom-brown);" id="dayModalTitle">
                    <i class="fas fa-calendar-day mr-2"></i>D√©tails du Jour
                </h3>
                <button class="text-2xl" onclick="closeModal('dayModal')">&times;</button>
            </div>
            
            <div id="dayModalContent">
                <!-- Content will be populated by JavaScript -->
            </div>
            
            <div class="flex justify-end space-x-4 mt-4">
                <button class="mushroom-btn px-4 py-2 rounded" onclick="addWeatherToDay()">
                    <i class="fas fa-cloud mr-2"></i>Ajouter M√©t√©o
                </button>
                <button class="mushroom-btn px-4 py-2 rounded" onclick="addHarvestToDay()">
                    <i class="fas fa-seedling mr-2"></i>Ajouter R√©colte
                </button>
            </div>
        </div>
    </div>

    <!-- Modal for Chart Details -->
    <div id="chartModal" class="modal">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold" style="color: var(--mushroom-brown);" id="chartModalTitle">
                    <i class="fas fa-chart-line mr-2"></i>D√©tails du Graphique
                </h3>
                <button class="text-2xl" onclick="closeModal('chartModal')">&times;</button>
            </div>
            
            <div id="chartModalContent">
                <!-- Content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Modal for Day Details -->
    <div id="dayDetailsModal" class="modal" role="dialog" aria-modal="true">
        <div class="modal-content print-area">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold" style="color: var(--mushroom-brown);" id="dayDetailsTitle">
                    <i class="fas fa-calendar-day mr-2"></i>D√©tails du Jour
                </h3>
                <button class="text-2xl" onclick="closeDayDetailsModal()">&times;</button>
            </div>
            
            <div id="dayDetailsContent">
                <!-- Content will be populated by JavaScript -->
            </div>
            

        </div>
    </div>

    <script>
                 // Global variables
         let currentPage = 'dashboard';
         let currentYear = new Date().getFullYear();
         let currentMonth = 0;
         let sortColumn = 'date'; // Colonne actuellement tri√©e (par d√©faut: date)
         let sortDirection = 'desc'; // Direction du tri (par d√©faut: d√©croissant pour avoir les plus r√©centes en haut)
         let charts = {}; // Pour stocker les instances de graphiques
         let editingHarvestIndex = -1; // Index de la r√©colte en cours d'√©dition (-1 = pas d'√©dition)
         
         // Couleurs pr√©d√©finies pour les vari√©t√©s
         const varietyColors = {
             'C√®pes de Bordeaux': 'rgba(139, 69, 19, 0.8)', // Marron actuel
             'Girolles': 'rgba(255, 215, 0, 0.8)', // Jaune
             'Pieds de mouton': 'rgba(255, 255, 255, 0.8)', // Blanc
             'Chanterelles': 'rgba(255, 140, 0, 0.8)', // Orange fonc√©
             'Coulemelles': 'rgba(128, 128, 128, 0.8)', // Gris
             'Bolet jaune': 'rgba(255, 165, 0, 0.8)', // Jaune fonc√©
             'Morilles': 'rgba(245, 245, 220, 0.8)' // Beige
         };
         
         // Couleurs pour les distances
         const distanceColors = {
             misu: 'rgba(34, 139, 34, 0.8)', // Vert doux
             misa: 'rgba(255, 182, 193, 0.8)' // Rose doux
         };
         
         // Fonction pour g√©n√©rer des couleurs al√©atoires pour les vari√©t√©s personnalis√©es
         function getRandomColor() {
             const colors = [
                 'rgba(255, 99, 132, 0.8)',   // Rouge
                 'rgba(54, 162, 235, 0.8)',   // Bleu
                 'rgba(255, 206, 86, 0.8)',   // Jaune
                 'rgba(75, 192, 192, 0.8)',   // Turquoise
                 'rgba(153, 102, 255, 0.8)',  // Violet
                 'rgba(255, 159, 64, 0.8)',   // Orange
                 'rgba(199, 199, 199, 0.8)',  // Gris
                 'rgba(83, 102, 255, 0.8)',   // Bleu indigo
                 'rgba(255, 99, 132, 0.8)',   // Rose
                 'rgba(255, 205, 86, 0.8)'    // Jaune clair
             ];
             return colors[Math.floor(Math.random() * colors.length)];
         }
         
         // Stockage des couleurs pour les vari√©t√©s personnalis√©es
         let customVarietyColors = {};
         
         // Mapping pour les dates du graphique des r√©coltes par jours
         let metaIndexToDate = {};
         
         // Fonction pour sauvegarder les couleurs personnalis√©es
         function saveCustomColors() {
             localStorage.setItem('customVarietyColors', JSON.stringify(customVarietyColors));
         }
         
         // Fonction pour charger les couleurs personnalis√©es
         function loadCustomColors() {
             const saved = localStorage.getItem('customVarietyColors');
             if (saved) {
                 customVarietyColors = JSON.parse(saved);
             }
         }
        
        // Data structure
        let appData = {
            years: {},
            settings: {
                varieties: ['C√®pes de Bordeaux', 'Girolles', 'Pieds de mouton', 'Chanterelles', 'Coulemelles', 'Bolet jaune', 'Morilles'],
                locations: ['For√™t des Pins', 'Bois de Ch√™nes', 'Clairi√®re Sud', 'Sentier du Nord'],
                defaultWeightUnit: 'kg',
                dateFormat: 'DD/MM/YYYY',
                maxPhotoSize: 15,
                autoBackup: false
            },
            dashboardPhotos: {} // Stockage des photos par ann√©e
        };

                 // Initialize app
         document.addEventListener('DOMContentLoaded', function() {
             loadData();
             loadCustomColors();
             
             // D√©terminer l'ann√©e courante bas√©e sur les donn√©es existantes
             const availableYears = Object.keys(appData.years)
                 .filter(year => {
                     const yearData = appData.years[year];
                     return yearData && yearData.harvests && yearData.harvests.length > 0;
                 })
                 .map(Number);
             
             // Si on a des donn√©es avec des r√©coltes, utiliser l'ann√©e la plus r√©cente
             if (availableYears.length > 0) {
                 currentYear = Math.max(...availableYears);
             } else {
                 // Sinon, utiliser l'ann√©e actuelle
                 currentYear = new Date().getFullYear();
             }
             
             initializeYear(currentYear);
             populateYearSelector();
             
             // Mettre √† jour l'affichage de l'ann√©e
             document.getElementById('currentYear').textContent = currentYear;
             
             showPage('dashboard');
             populateSettings();
             
           // Sauvegarder les donn√©es initiales si elles n'existent pas
           if (!localStorage.getItem('mushroomHarvestData')) {
               saveData();
           }
            
                         // Attendre que tous les √©l√©ments soient charg√©s avant de mettre √† jour le dashboard
             function initializeDashboard() {
                 if (ensureElementsLoaded()) {
                     // S'assurer que toutes les r√©coltes existantes sont dans le calendrier
                     ensureAllHarvestsInCalendar();
                     
                     // Test de validation de la nouvelle logique de comptage des sorties
                     testUniqueOutingsCount();
                     
                     // Test de validation du calcul de dur√©e et plage horaire
                     testDaySummaryCalculations();
                     
                     // Test de validation du calcul du cumul par vari√©t√©
                     testVarietyCumulCalculations();
                     
                     // Test de validation du calcul du cumul par emplacement
                     testLocationCumulCalculations();
                     
                     // Test de validation du calcul de la vari√©t√© dominante par jour
                     testDominantVarietyCalculations();
                     
                     // Test de validation du graphique empil√©
                     testStackedChartCalculations();
                     
                     updateDashboard();
                     generateCalendar();
                     loadDashboardPhotos();
                 } else {
                     // Si les √©l√©ments ne sont pas encore charg√©s, r√©essayer apr√®s un d√©lai
                     setTimeout(initializeDashboard, 50);
                 }
             }
            
                         setTimeout(initializeDashboard, 100);
             
             // Plus besoin de v√©rifier l'ann√©e automatiquement
        });
        
                 // Fonction pour v√©rifier que tous les √©l√©ments n√©cessaires sont charg√©s
         function ensureElementsLoaded() {
             const requiredElements = [
                 'totalWeight', 'totalOutings', 'totalVarieties', 'bestHarvest',
                 'weeklyChart', 'varietyChart', 'distanceChart'
             ];
             
             for (let i = 0; i < 5; i++) {
                 requiredElements.push(`dashPhoto${i}`);
                 requiredElements.push(`removePhoto${i}`);
             }
             
             return requiredElements.every(id => document.getElementById(id) !== null);
         }

                 // Navigation functions
         function showPage(pageId) {
             document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
             document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
             
             document.getElementById(pageId).classList.add('active');
             
             // Trouver le bouton correspondant et l'activer
             const buttons = document.querySelectorAll('.nav-btn');
             buttons.forEach(btn => {
                 if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(pageId)) {
                     btn.classList.add('active');
                 }
             });
             
             currentPage = pageId;
             
             // Synchroniser les s√©lecteurs d'ann√©e lors du changement de page
             const selector = document.getElementById('yearSelector');
             const selectorHarvests = document.getElementById('yearSelectorHarvests');
             const selectorCalendar = document.getElementById('yearSelectorCalendar');
             if (selector && selectorHarvests && selectorCalendar) {
                 selector.value = currentYear;
                 selectorHarvests.value = currentYear;
                 selectorCalendar.value = currentYear;
             }
             
             // Mettre √† jour les affichages d'ann√©e
             const currentYearEl = document.getElementById('currentYear');
             const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
             const currentYearCalendarEl = document.getElementById('currentYearCalendar');
             if (currentYearEl) currentYearEl.textContent = currentYear;
             if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = currentYear;
             if (currentYearCalendarEl) currentYearCalendarEl.textContent = currentYear;
             
             if (pageId === 'dashboard') updateDashboard();
             if (pageId === 'calendar') generateCalendar();
             if (pageId === 'harvests') populateHarvestsTable();
         }

        

        // Year management
                 function changeYear() {
             currentYear = parseInt(document.getElementById('yearSelector').value);
             
             // Synchroniser les s√©lecteurs
             const selectorHarvests = document.getElementById('yearSelectorHarvests');
             const selectorCalendar = document.getElementById('yearSelectorCalendar');
             if (selectorHarvests) selectorHarvests.value = currentYear;
             if (selectorCalendar) selectorCalendar.value = currentYear;
             
             // Mettre √† jour les affichages d'ann√©e
             const currentYearEl = document.getElementById('currentYear');
             const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
             const currentYearCalendarEl = document.getElementById('currentYearCalendar');
             if (currentYearEl) currentYearEl.textContent = currentYear;
             if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = currentYear;
             if (currentYearCalendarEl) currentYearCalendarEl.textContent = currentYear;
             
             initializeYear(currentYear);
             updateDashboard();
             generateCalendar();
             loadDashboardPhotos(); // Recharger les photos pour la nouvelle ann√©e
             
             // R√©initialiser le tri par d√©faut lors du changement d'ann√©e
             sortColumn = 'date';
             sortDirection = 'desc';
             populateHarvestsTable();
         }
         
         function changeYearFromHarvests() {
             currentYear = parseInt(document.getElementById('yearSelectorHarvests').value);
             
             // Synchroniser les s√©lecteurs
             const selector = document.getElementById('yearSelector');
             const selectorCalendar = document.getElementById('yearSelectorCalendar');
             if (selector) selector.value = currentYear;
             if (selectorCalendar) selectorCalendar.value = currentYear;
             
             // Mettre √† jour les affichages d'ann√©e
             const currentYearEl = document.getElementById('currentYear');
             const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
             const currentYearCalendarEl = document.getElementById('currentYearCalendar');
             if (currentYearEl) currentYearEl.textContent = currentYear;
             if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = currentYear;
             if (currentYearCalendarEl) currentYearCalendarEl.textContent = currentYear;
             
             initializeYear(currentYear);
             updateDashboard();
             generateCalendar();
             loadDashboardPhotos(); // Recharger les photos pour la nouvelle ann√©e
             // R√©initialiser le tri par d√©faut lors du changement d'ann√©e
             sortColumn = 'date';
             sortDirection = 'desc';
             populateHarvestsTable();
         }
         
         function changeYearFromCalendar() {
             currentYear = parseInt(document.getElementById('yearSelectorCalendar').value);
             
             // Synchroniser les s√©lecteurs
             const selector = document.getElementById('yearSelector');
             const selectorHarvests = document.getElementById('yearSelectorHarvests');
             if (selector) selector.value = currentYear;
             if (selectorHarvests) selectorHarvests.value = currentYear;
             
             // Mettre √† jour les affichages d'ann√©e
             const currentYearEl = document.getElementById('currentYear');
             const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
             const currentYearCalendarEl = document.getElementById('currentYearCalendar');
             if (currentYearEl) currentYearEl.textContent = currentYear;
             if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = currentYear;
             if (currentYearCalendarEl) currentYearCalendarEl.textContent = currentYear;
             
             initializeYear(currentYear);
             updateDashboard();
             generateCalendar();
             loadDashboardPhotos(); // Recharger les photos pour la nouvelle ann√©e
             // R√©initialiser le tri par d√©faut lors du changement d'ann√©e
             sortColumn = 'date';
             sortDirection = 'desc';
             populateHarvestsTable();
         }
         
         // Fonction pour v√©rifier et mettre √† jour l'ann√©e courante
         function checkAndUpdateCurrentYear() {
             // Ne plus changer automatiquement l'ann√©e bas√©e sur la date actuelle
             // L'ann√©e sera d√©termin√©e par les donn√©es existantes ou par la s√©lection manuelle
             return;
         }

                 function populateYearSelector() {
             const selector = document.getElementById('yearSelector');
             const selectorHarvests = document.getElementById('yearSelectorHarvests');
             const selectorCalendar = document.getElementById('yearSelectorCalendar');
             
             if (selector) selector.innerHTML = '';
             if (selectorHarvests) selectorHarvests.innerHTML = '';
             if (selectorCalendar) selectorCalendar.innerHTML = '';

             const years = Object.keys(appData.years)
                 .filter(y => {
                     const d = appData.years[y];
                     return d && d.harvests && d.harvests.length > 0;
                 })
                 .map(Number)
                 .sort((a,b) => a - b);

             if (years.length === 0) {
                 // Aucune ann√©e avec r√©colte ‚Üí les s√©lecteurs ne doivent rien proposer
                 if (selector) {
                     selector.disabled = true;
                     const opt = document.createElement('option');
                     opt.value = '';
                     opt.textContent = '‚Äî';
                     selector.appendChild(opt);
                 }
                 if (selectorHarvests) {
                     selectorHarvests.disabled = true;
                     const opt = document.createElement('option');
                     opt.value = '';
                     opt.textContent = '‚Äî';
                     selectorHarvests.appendChild(opt);
                 }
                 if (selectorCalendar) {
                     selectorCalendar.disabled = true;
                     const opt = document.createElement('option');
                     opt.value = '';
                     opt.textContent = '‚Äî';
                     selectorCalendar.appendChild(opt);
                 }
                 
                 const currentYearEl = document.getElementById('currentYear');
                 const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
                 const currentYearCalendarEl = document.getElementById('currentYearCalendar');
                 if (currentYearEl) currentYearEl.textContent = '‚Äî';
                 if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = '‚Äî';
                 if (currentYearCalendarEl) currentYearCalendarEl.textContent = '‚Äî';
                 return;
             }

             if (selector) selector.disabled = false;
             if (selectorHarvests) selectorHarvests.disabled = false;
             if (selectorCalendar) selectorCalendar.disabled = false;
             
             years.forEach(y => {
                 const opt = document.createElement('option');
                 opt.value = y;
                 opt.textContent = y;
                 if (selector) selector.appendChild(opt);
                 
                 const optHarvests = document.createElement('option');
                 optHarvests.value = y;
                 optHarvests.textContent = y;
                 if (selectorHarvests) selectorHarvests.appendChild(optHarvests);
                 
                 const optCalendar = document.createElement('option');
                 optCalendar.value = y;
                 optCalendar.textContent = y;
                 if (selectorCalendar) selectorCalendar.appendChild(optCalendar);
             });

             // Si l'ann√©e courante n'est pas dans la liste, prendre la plus r√©cente
             if (!years.includes(currentYear)) {
                 currentYear = Math.max(...years);
             }
             
             if (selector) selector.value = currentYear;
             if (selectorHarvests) selectorHarvests.value = currentYear;
             if (selectorCalendar) selectorCalendar.value = currentYear;
             
             const currentYearEl = document.getElementById('currentYear');
             const currentYearHarvestsEl = document.getElementById('currentYearHarvests');
             const currentYearCalendarEl = document.getElementById('currentYearCalendar');
             if (currentYearEl) currentYearEl.textContent = currentYear;
             if (currentYearHarvestsEl) currentYearHarvestsEl.textContent = currentYear;
             if (currentYearCalendarEl) currentYearCalendarEl.textContent = currentYear;
         }
         
         function addNewYear() {
             const year = prompt('Entrez l\'ann√©e √† ajouter:', new Date().getFullYear());
             if (year && !isNaN(year)) {
                 const yearInt = parseInt(year);
                 initializeYear(yearInt);
                 saveData();
                 populateYearSelector();
             }
         }

        function initializeYear(year) {
            if (!appData.years[year]) {
                appData.years[year] = {
                    harvests: [],
                    calendar: {}
                };
            }
        }

        // Dashboard functions
        // Fonction utilitaire pour calculer le nombre de sorties uniques par jour
        // Si plusieurs r√©coltes ont lieu le m√™me jour, cela ne compte que pour 1 sortie
        function getUniqueOutingsCount(harvests) {
            // Cr√©er un Set des dates uniques pour √©viter les doublons
            const uniqueDates = new Set(harvests.map(h => h.date).filter(date => date));
            return uniqueDates.size;
        }
        
        // Fonction de test pour valider le comportement (√† supprimer apr√®s validation)
        function testUniqueOutingsCount() {
            const testHarvests = [
                { date: '2024-01-01', weight: 1.5 },
                { date: '2024-01-01', weight: 2.0 }, // M√™me jour
                { date: '2024-01-02', weight: 1.0 },
                { date: '2024-01-03', weight: 0.5 },
                { date: '2024-01-03', weight: 1.2 }, // M√™me jour
                { date: '2024-01-03', weight: 0.8 }  // M√™me jour
            ];
            
            const uniqueCount = getUniqueOutingsCount(testHarvests);
            const totalCount = testHarvests.length;
            
            console.log('Test getUniqueOutingsCount:');
            console.log('- Nombre total de r√©coltes:', totalCount);
            console.log('- Nombre de sorties uniques:', uniqueCount);
            console.log('- R√©sultat attendu: 3 sorties (2024-01-01, 2024-01-02, 2024-01-03)');
            console.log('- R√©sultat obtenu:', uniqueCount, 'sorties');
            
            return uniqueCount === 3;
        }
        
        // Fonction de test pour valider le calcul de dur√©e et plage horaire
        function testDaySummaryCalculations() {
            const testDayHarvests = [
                { date: '2024-01-01', time: '09:00', duration: 3.5, weight: 1.5 },
                { date: '2024-01-01', time: '10:30', duration: 2.0, weight: 2.0 },
                { date: '2024-01-01', time: '14:00', duration: 1.5, weight: 0.8 }
            ];
            
            // Simuler le calcul de la fonction buildDaySummary
            let totalDuration = 0;
            let earliestTime = null;
            
            testDayHarvests.forEach(h => {
                if (h.duration && parseFloat(h.duration) > 0) {
                    totalDuration += parseFloat(h.duration);
                }
                if (h.time) {
                    if (!earliestTime || h.time < earliestTime) {
                        earliestTime = h.time;
                    }
                }
            });
            
            // Calculer l'heure de fin
            let latestTime = null;
            if (earliestTime && totalDuration > 0) {
                const startTime = new Date(`2000-01-01T${earliestTime}:00`);
                const endTime = new Date(startTime.getTime() + (totalDuration * 60 * 60 * 1000));
                latestTime = endTime.toTimeString().slice(0, 5);
            }
            
            console.log('Test buildDaySummary:');
            console.log('- Heure d\'arriv√©e la plus t√¥t:', earliestTime);
            console.log('- Dur√©e totale:', totalDuration, 'heures');
            console.log('- Heure de fin calcul√©e:', latestTime);
            console.log('- R√©sultat attendu: 09:00 - 16:00 (7h de dur√©e totale)');
            console.log('- R√©sultat obtenu:', earliestTime, '-', latestTime);
            
            return earliestTime === '09:00' && totalDuration === 7 && latestTime === '16:00';
        }
        
        // Fonction de test pour valider le calcul du cumul par vari√©t√©
        function testVarietyCumulCalculations() {
            // Simuler des r√©coltes sur plusieurs jours
            const testYearHarvests = [
                { date: '2024-01-01', variety: 'Girolles', weight: 1.5 },
                { date: '2024-01-05', variety: 'Girolles', weight: 2.0 },
                { date: '2024-01-10', variety: 'Girolles', weight: 0.8 },
                { date: '2024-01-02', variety: 'C√®pes de Bordeaux', weight: 1.2 },
                { date: '2024-01-08', variety: 'C√®pes de Bordeaux', weight: 0.5 }
            ];
            
            // Simuler le calcul du cumul
            const varietyCumul = {};
            const varietyFirstHarvest = {};
            
            testYearHarvests.forEach(h => {
                if (h.variety) {
                    if (!varietyCumul[h.variety]) {
                        varietyCumul[h.variety] = 0;
                        varietyFirstHarvest[h.variety] = h.date;
                    }
                    varietyCumul[h.variety] += parseFloat(h.weight) || 0;
                }
            });
            
            console.log('Test calcul cumul par vari√©t√©:');
            console.log('- Girolles cumul:', varietyCumul['Girolles'], 'kg (attendu: 4.3 kg)');
            console.log('- C√®pes de Bordeaux cumul:', varietyCumul['C√®pes de Bordeaux'], 'kg (attendu: 1.7 kg)');
            console.log('- Premi√®re r√©colte Girolles:', varietyFirstHarvest['Girolles'], '(attendu: 2024-01-01)');
            console.log('- Premi√®re r√©colte C√®pes:', varietyFirstHarvest['C√®pes de Bordeaux'], '(attendu: 2024-01-02)');
            
            return varietyCumul['Girolles'] === 4.3 && 
                   varietyCumul['C√®pes de Bordeaux'] === 1.7 &&
                   varietyFirstHarvest['Girolles'] === '2024-01-01' &&
                   varietyFirstHarvest['C√®pes de Bordeaux'] === '2024-01-02';
        }
        
        // Fonction de test pour valider le calcul du cumul par emplacement
        function testLocationCumulCalculations() {
            // Simuler des r√©coltes sur plusieurs jours avec emplacements
            const testYearHarvests = [
                { date: '2024-01-01', location: 'Col Andrion', weight: 1.5 },
                { date: '2024-01-05', location: 'Col Andrion', weight: 2.0 },
                { date: '2024-01-10', location: 'Col Andrion', weight: 0.8 },
                { date: '2024-01-02', location: 'Vers les baignoires et plus haut', weight: 1.2 },
                { date: '2024-01-08', location: 'Vers les baignoires et plus haut', weight: 0.5 },
                { date: '2024-01-15', location: 'Nouveau spot', weight: 1.0 }
            ];
            
            // Simuler le calcul du cumul
            const locationCumul = {};
            const locationFirstHarvest = {};
            
            testYearHarvests.forEach(h => {
                if (h.location) {
                    if (!locationCumul[h.location]) {
                        locationCumul[h.location] = 0;
                        locationFirstHarvest[h.location] = h.date;
                    }
                    locationCumul[h.location] += parseFloat(h.weight) || 0;
                }
            });
            
            console.log('Test calcul cumul par emplacement:');
            console.log('- Col Andrion cumul:', locationCumul['Col Andrion'], 'kg (attendu: 4.3 kg)');
            console.log('- Vers les baignoires et plus haut cumul:', locationCumul['Vers les baignoires et plus haut'], 'kg (attendu: 1.7 kg)');
            console.log('- Nouveau spot cumul:', locationCumul['Nouveau spot'], 'kg (attendu: 1.0 kg)');
            console.log('- Premi√®re r√©colte Col Andrion:', locationFirstHarvest['Col Andrion'], '(attendu: 2024-01-01)');
            console.log('- Premi√®re r√©colte Vers les baignoires:', locationFirstHarvest['Vers les baignoires et plus haut'], '(attendu: 2024-01-02)');
            console.log('- Premi√®re r√©colte Nouveau spot:', locationFirstHarvest['Nouveau spot'], '(attendu: 2024-01-15)');
            
            return locationCumul['Col Andrion'] === 4.3 && 
                   locationCumul['Vers les baignoires et plus haut'] === 1.7 &&
                   locationCumul['Nouveau spot'] === 1.0 &&
                   locationFirstHarvest['Col Andrion'] === '2024-01-01' &&
                   locationFirstHarvest['Vers les baignoires et plus haut'] === '2024-01-02' &&
                   locationFirstHarvest['Nouveau spot'] === '2024-01-15';
        }
        
        // Fonction de test pour valider le calcul de la vari√©t√© dominante par jour
        function testDominantVarietyCalculations() {
            // Simuler des r√©coltes sur plusieurs jours avec diff√©rentes vari√©t√©s
            const testHarvests = [
                { date: '2024-01-01', variety: 'Girolles', weight: 1.5 },
                { date: '2024-01-01', variety: 'C√®pes de Bordeaux', weight: 0.8 },
                { date: '2024-01-02', variety: 'C√®pes de Bordeaux', weight: 2.0 },
                { date: '2024-01-02', variety: 'Girolles', weight: 0.5 },
                { date: '2024-01-03', variety: 'Pieds de mouton', weight: 1.2 },
                { date: '2024-01-03', variety: 'Girolles', weight: 0.3 }
            ];
            
            // Simuler le calcul de la vari√©t√© dominante par jour
            const dailyDominantVariety = {};
            
            testHarvests.forEach(harvest => {
                if (harvest.date) {
                    if (!dailyDominantVariety[harvest.date]) {
                        dailyDominantVariety[harvest.date] = {};
                    }
                    
                    if (harvest.variety) {
                        if (!dailyDominantVariety[harvest.date][harvest.variety]) {
                            dailyDominantVariety[harvest.date][harvest.variety] = 0;
                        }
                        dailyDominantVariety[harvest.date][harvest.variety] += parseFloat(harvest.weight) || 0;
                    }
                }
            });
            
            // Fonction pour identifier la vari√©t√© dominante d'un jour
            function getDominantVariety(dayVarieties) {
                let maxWeight = 0;
                let dominantVariety = null;
                
                for (const [variety, weight] of Object.entries(dayVarieties)) {
                    if (weight > maxWeight) {
                        maxWeight = weight;
                        dominantVariety = variety;
                    }
                }
                
                return dominantVariety;
            }
            
            console.log('Test calcul vari√©t√© dominante par jour:');
            console.log('- 2024-01-01 dominante:', getDominantVariety(dailyDominantVariety['2024-01-01']), '(attendu: Girolles)');
            console.log('- 2024-01-02 dominante:', getDominantVariety(dailyDominantVariety['2024-01-02']), '(attendu: C√®pes de Bordeaux)');
            console.log('- 2024-01-03 dominante:', getDominantVariety(dailyDominantVariety['2024-01-03']), '(attendu: Pieds de mouton)');
            
            return getDominantVariety(dailyDominantVariety['2024-01-01']) === 'Girolles' &&
                   getDominantVariety(dailyDominantVariety['2024-01-02']) === 'C√®pes de Bordeaux' &&
                   getDominantVariety(dailyDominantVariety['2024-01-03']) === 'Pieds de mouton';
        }
        
        // Fonction de test pour valider le graphique empil√©
        function testStackedChartCalculations() {
            // Simuler des r√©coltes sur plusieurs jours avec diff√©rentes vari√©t√©s
            const testHarvests = [
                { date: '2024-01-01', variety: 'Girolles', weight: 1.5 },
                { date: '2024-01-01', variety: 'C√®pes de Bordeaux', weight: 0.8 },
                { date: '2024-01-02', variety: 'C√®pes de Bordeaux', weight: 2.0 },
                { date: '2024-01-02', variety: 'Girolles', weight: 0.5 },
                { date: '2024-01-03', variety: 'Pieds de mouton', weight: 1.2 },
                { date: '2024-01-03', variety: 'Girolles', weight: 0.3 }
            ];
            
            // Simuler le calcul pour le graphique empil√©
            const dailyDominantVariety = {};
            
            testHarvests.forEach(harvest => {
                if (harvest.date) {
                    if (!dailyDominantVariety[harvest.date]) {
                        dailyDominantVariety[harvest.date] = {};
                    }
                    
                    if (harvest.variety) {
                        if (!dailyDominantVariety[harvest.date][harvest.variety]) {
                            dailyDominantVariety[harvest.date][harvest.variety] = 0;
                        }
                        dailyDominantVariety[harvest.date][harvest.variety] += parseFloat(harvest.weight) || 0;
                    }
                }
            });
            
            // R√©cup√©rer toutes les vari√©t√©s
            const allVarieties = new Set();
            Object.values(dailyDominantVariety).forEach(dayVarieties => {
                Object.keys(dayVarieties).forEach(variety => {
                    allVarieties.add(variety);
                });
            });
            
            const varietyList = Array.from(allVarieties);
            const sortedDays = Object.keys(dailyDominantVariety).sort();
            
            console.log('Test graphique empil√©:');
            console.log('- Vari√©t√©s trouv√©es:', varietyList);
            console.log('- Jours avec r√©coltes:', sortedDays);
            console.log('- Donn√©es par jour:');
            sortedDays.forEach(day => {
                console.log(`  ${day}:`, dailyDominantVariety[day]);
            });
            
            // V√©rifier que toutes les vari√©t√©s sont pr√©sentes
            const expectedVarieties = ['Girolles', 'C√®pes de Bordeaux', 'Pieds de mouton'];
            const hasAllVarieties = expectedVarieties.every(v => varietyList.includes(v));
            
            return hasAllVarieties && varietyList.length === 3 && sortedDays.length === 3;
        }
        
        function updateDashboard() {
            const yearData = appData.years[currentYear] || { harvests: [] };
            const harvests = yearData.harvests;
            
            // Update statistics
            const totalWeight = harvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0);
            const totalOutings = getUniqueOutingsCount(harvests); // Utiliser la nouvelle logique
            const varieties = [...new Set(harvests.map(h => h.variety).filter(v => v))];
            const bestHarvest = Math.max(...harvests.map(h => parseFloat(h.weight) || 0), 0);
            
            // V√©rifier que les √©l√©ments existent avant de les mettre √† jour
            const totalWeightEl = document.getElementById('totalWeight');
            const totalOutingsEl = document.getElementById('totalOutings');
            const totalVarietiesEl = document.getElementById('totalVarieties');
            const bestHarvestEl = document.getElementById('bestHarvest');
            
            if (totalWeightEl) totalWeightEl.textContent = totalWeight.toFixed(2) + ' kg';
            if (totalOutingsEl) totalOutingsEl.textContent = totalOutings;
            if (totalVarietiesEl) totalVarietiesEl.textContent = varieties.length;
            if (bestHarvestEl) bestHarvestEl.textContent = bestHarvest.toFixed(2) + ' kg';
            
                         // Update charts
             updateWeeklyChart(harvests);
             updateVarietyChart(harvests);
             updateDistanceChart(harvests);
            
            // Load dashboard photos
            loadDashboardPhotos();
        }

                 function updateWeeklyChart(harvests) {
             const canvas = document.getElementById('weeklyChart');
             if (!canvas) return;
             
             // D√©truire le graphique existant s'il existe
             if (charts.weeklyChart) {
                 charts.weeklyChart.destroy();
             }
             
             const ctx = canvas.getContext('2d');
             
             // Grouper les r√©coltes par jour et identifier la vari√©t√© dominante
             const dailyData = {};
             const dailyDominantVariety = {};
             
             harvests.forEach(harvest => {
                 if (harvest.date) {
                     const dateKey = harvest.date; // Utiliser directement la date
                     
                     if (!dailyData[dateKey]) {
                         dailyData[dateKey] = 0;
                         dailyDominantVariety[dateKey] = {};
                     }
                     
                     dailyData[dateKey] += parseFloat(harvest.weight) || 0;
                     
                     // Compter le poids par vari√©t√© pour ce jour
                     if (harvest.variety) {
                         if (!dailyDominantVariety[dateKey][harvest.variety]) {
                             dailyDominantVariety[dateKey][harvest.variety] = 0;
                         }
                         dailyDominantVariety[dateKey][harvest.variety] += parseFloat(harvest.weight) || 0;
                     }
                 }
             });
             
             // Trier par date et limiter aux 20 derniers jours
             const sortedDays = Object.keys(dailyData).sort().slice(-20);
             const labels = sortedDays.map(day => {
                 const date = new Date(day);
                 return `${date.getDate()}/${date.getMonth() + 1}`;
             });
             const data = sortedDays.map(day => dailyData[day]);
             
             // Cr√©er le mapping index ‚Üí date ISO
             metaIndexToDate = {};
             sortedDays.forEach((day, index) => {
                 metaIndexToDate[index] = day;
             });
             
             // Fonction pour obtenir la couleur d'une vari√©t√©
             function getVarietyColor(variety) {
                 // Si c'est une vari√©t√© pr√©d√©finie, utiliser sa couleur
                 if (varietyColors[variety]) {
                     return varietyColors[variety];
                 }
                 // Si c'est une vari√©t√© personnalis√©e, g√©n√©rer ou r√©cup√©rer sa couleur
                 if (!customVarietyColors[variety]) {
                     customVarietyColors[variety] = getRandomColor();
                 }
                 return customVarietyColors[variety];
             }
             
             // Fonction pour identifier la vari√©t√© dominante d'un jour
             function getDominantVariety(dayVarieties) {
                 let maxWeight = 0;
                 let dominantVariety = null;
                 
                 for (const [variety, weight] of Object.entries(dayVarieties)) {
                     if (weight > maxWeight) {
                         maxWeight = weight;
                         dominantVariety = variety;
                     }
                 }
                 
                 return dominantVariety;
             }
             
             // Pr√©parer les donn√©es pour un graphique empil√©
             const allVarieties = new Set();
             sortedDays.forEach(day => {
                 Object.keys(dailyDominantVariety[day] || {}).forEach(variety => {
                     allVarieties.add(variety);
                 });
             });
             
             const varietyList = Array.from(allVarieties);
             
             // Cr√©er un dataset pour chaque vari√©t√©
             const datasets = varietyList.map(variety => {
                 const data = sortedDays.map(day => {
                     return dailyDominantVariety[day]?.[variety] || 0;
                 });
                 
                 return {
                     label: variety,
                     data: data,
                     backgroundColor: getVarietyColor(variety),
                     borderColor: getVarietyColor(variety).replace('0.8', '1'),
                     borderWidth: 1
                 };
             });
             
             charts.weeklyChart = new Chart(ctx, {
                 type: 'bar',
                 data: {
                     labels: labels,
                     datasets: datasets
                 },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     plugins: {
                         legend: {
                             display: true,
                             position: 'bottom'
                         },
                         tooltip: {
                             callbacks: {
                                 title: function(context) {
                                     const dayIndex = context[0].dataIndex;
                                     const day = sortedDays[dayIndex];
                                     const date = new Date(day);
                                     return date.toLocaleDateString('fr-FR');
                                 },
                                 label: function(context) {
                                     return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' kg';
                                 }
                             }
                         }
                     },
                     scales: {
                         x: {
                             stacked: true
                         },
                         y: {
                             stacked: true,
                             beginAtZero: true,
                             ticks: {
                                 stepSize: 1,
                                 callback: function(value) {
                                     return Math.round(value);
                                 }
                             }
                         }
                     }
                 }
             });
             
             // Ajouter l'√©v√©nement de clic sur tout l'encadr√© du graphique
             const container = document.getElementById('weeklyChartContainer');
             if (container) {
                 container.addEventListener('click', function(evt) {
                     // Toujours afficher le bilan global de tous les jours
                     const summary = {
                         dateISO: new Date().toISOString().split('T')[0], // Date actuelle pour le titre
                         totalKg: harvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0),
                         count: getUniqueOutingsCount(harvests), // Utiliser la nouvelle logique
                         distinctVarieties: new Set(harvests.map(h => h.variety).filter(Boolean)).size,
                         timeMin: null,
                         timeMax: null,
                         weather: null,
                         byVariety: [],
                         byLocation: [],
                         entries: harvests.map(h => ({
                             time: h.time || '',
                             variety: h.variety || '',
                             weightKg: parseFloat(h.weight) || 0,
                             location: h.location || '',
                             duration: h.duration || '',
                             distances: h.distanceMisu || h.distanceMisa || h.distance || '',
                             comment: h.comment || '',
                             photoUrl: h.photo || ''
                         }))
                     };
                     
                     // Calculer les top par vari√©t√©
                     const varietyData = {};
                     harvests.forEach(harvest => {
                         if (harvest.variety) {
                             varietyData[harvest.variety] = (varietyData[harvest.variety] || 0) + (parseFloat(harvest.weight) || 0);
                         }
                     });
                     summary.byVariety = Object.entries(varietyData)
                         .map(([name, kg]) => ({ 
                             name, 
                             kg, 
                             count: harvests.filter(h => h.variety === name).length 
                         }))
                         .sort((a, b) => b.kg - a.kg);
                     
                     // Calculer les top par emplacement
                     const locationData = {};
                     harvests.forEach(harvest => {
                         if (harvest.location) {
                             locationData[harvest.location] = (locationData[harvest.location] || 0) + (parseFloat(harvest.weight) || 0);
                         }
                     });
                     summary.byLocation = Object.entries(locationData)
                         .map(([name, kg]) => ({ 
                             name, 
                             kg, 
                             count: harvests.filter(h => h.location === name).length 
                         }))
                         .sort((a, b) => b.kg - a.kg);
                     
                     showDayModal(summary);
                 });
             }
         }

                 function updateVarietyChart(harvests) {
             const canvas = document.getElementById('varietyChart');
             if (!canvas) return;
             
             // D√©truire le graphique existant s'il existe
             if (charts.varietyChart) {
                 charts.varietyChart.destroy();
             }
             
             const ctx = canvas.getContext('2d');
             
             const varietyData = {};
             harvests.forEach(harvest => {
                 if (harvest.variety) {
                     varietyData[harvest.variety] = (varietyData[harvest.variety] || 0) + (parseFloat(harvest.weight) || 0);
                 }
             });
             
             // G√©n√©rer les couleurs pour chaque vari√©t√©
             const colors = Object.keys(varietyData).map(variety => {
                 // Si c'est une vari√©t√© pr√©d√©finie, utiliser sa couleur
                 if (varietyColors[variety]) {
                     return varietyColors[variety];
                 }
                 // Si c'est une vari√©t√© personnalis√©e, g√©n√©rer ou r√©cup√©rer sa couleur
                 if (!customVarietyColors[variety]) {
                     customVarietyColors[variety] = getRandomColor();
                 }
                 return customVarietyColors[variety];
             });
             
             charts.varietyChart = new Chart(ctx, {
                 type: 'doughnut',
                 data: {
                     labels: Object.keys(varietyData),
                     datasets: [{
                         data: Object.values(varietyData),
                         backgroundColor: colors,
                         borderColor: colors.map(c => c.replace('0.8', '1')),
                         borderWidth: 2
                     }]
                 },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     plugins: {
                         legend: {
                             position: 'bottom'
                         },
                         tooltip: {
                             callbacks: {
                                 label: function(context) {
                                     return context.label + ': ' + context.parsed.toFixed(2) + ' kg';
                                 }
                             }
                         }
                     }
                 }
             });
             
             // Ajouter l'√©v√©nement de clic sur tout l'encadr√© du graphique des vari√©t√©s
             const varietyContainer = document.getElementById('varietyChartContainer');
             if (varietyContainer) {
                 varietyContainer.addEventListener('click', function(evt) {
                     // Calculer les statistiques d√©taill√©es des vari√©t√©s
                     const varietyStats = {};
                     harvests.forEach(harvest => {
                         if (harvest.variety) {
                             if (!varietyStats[harvest.variety]) {
                                 varietyStats[harvest.variety] = {
                                     totalKg: 0,
                                     count: 0,
                                     avgWeight: 0,
                                     minWeight: Infinity,
                                     maxWeight: 0,
                                     locations: new Set(),
                                     dates: new Set()
                                 };
                             }
                             const weight = parseFloat(harvest.weight) || 0;
                             varietyStats[harvest.variety].totalKg += weight;
                             varietyStats[harvest.variety].count += 1;
                             varietyStats[harvest.variety].minWeight = Math.min(varietyStats[harvest.variety].minWeight, weight);
                             varietyStats[harvest.variety].maxWeight = Math.max(varietyStats[harvest.variety].maxWeight, weight);
                             if (harvest.location) varietyStats[harvest.variety].locations.add(harvest.location);
                             if (harvest.date) varietyStats[harvest.variety].dates.add(harvest.date);
                         }
                     });
                     
                     // Calculer les moyennes et pourcentages
                     const totalKg = harvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0);
                     const varietyData = Object.entries(varietyStats).map(([name, data]) => {
                         data.avgWeight = data.totalKg / data.count;
                         data.percentage = (data.totalKg / totalKg * 100).toFixed(1);
                         data.locationCount = data.locations.size;
                         data.dateCount = data.dates.size;
                         return { name, ...data };
                     }).sort((a, b) => b.totalKg - a.totalKg);
                     
                     // Cr√©er un r√©sum√© sp√©cialis√© pour les vari√©t√©s
                     const summary = {
                         dateISO: new Date().toISOString().split('T')[0],
                         totalKg: totalKg,
                         count: getUniqueOutingsCount(harvests), // Utiliser la nouvelle logique
                         distinctVarieties: varietyData.length,
                         timeMin: null,
                         timeMax: null,
                         weather: null,
                         byVariety: varietyData.map(v => ({
                             name: v.name,
                             kg: v.totalKg,
                             count: v.count,
                             percentage: v.percentage,
                             avgWeight: v.avgWeight,
                             minWeight: v.minWeight,
                             maxWeight: v.maxWeight,
                             locationCount: v.locationCount,
                             dateCount: v.dateCount
                         })),
                         byLocation: [],
                         entries: harvests.map(h => ({
                             time: h.time || '',
                             variety: h.variety || '',
                             weightKg: parseFloat(h.weight) || 0,
                             location: h.location || '',
                             duration: h.duration || '',
                             distances: h.distanceMisu || h.distanceMisa || h.distance || '',
                             comment: h.comment || '',
                             photoUrl: h.photo || ''
                         }))
                     };
                     
                     showDayModal(summary);
                 });
             }
         }
         
         function updateDistanceChart(harvests) {
             const canvas = document.getElementById('distanceChart');
             if (!canvas) return;
             
             // D√©truire le graphique existant s'il existe
             if (charts.distanceChart) {
                 charts.distanceChart.destroy();
             }
             
             const ctx = canvas.getContext('2d');
             
             // Filtrer les r√©coltes avec des distances enregistr√©es (nouveau format ou ancien)
             const distanceData = harvests
                 .filter(harvest => {
                     const hasMisu = harvest.distanceMisu && parseFloat(harvest.distanceMisu) > 0;
                     const hasMisa = harvest.distanceMisa && parseFloat(harvest.distanceMisa) > 0;
                     const hasOldDistance = harvest.distance && parseFloat(harvest.distance) > 0;
                     return hasMisu || hasMisa || hasOldDistance;
                 })
                 .map(harvest => ({
                     date: harvest.date,
                     misu: harvest.distanceMisu ? parseFloat(harvest.distanceMisu) : 0,
                     misa: harvest.distanceMisa ? parseFloat(harvest.distanceMisa) : 0,
                     // Pour compatibilit√© avec l'ancien format
                     oldDistance: harvest.distance ? parseFloat(harvest.distance) : 0
                 }))
                 .sort((a, b) => new Date(a.date) - new Date(b.date));
             
             const labels = distanceData.map(item => {
                 const date = new Date(item.date);
                 return `${date.getDate()}/${date.getMonth() + 1}`;
             });
             
             const misuData = distanceData.map(item => item.misu);
             const misaData = distanceData.map(item => item.misa);
             const oldDistanceData = distanceData.map(item => item.oldDistance);
             
             // Si on a des donn√©es dans l'ancien format, les utiliser
             const hasNewFormat = misuData.some(d => d > 0) || misaData.some(d => d > 0);
             const hasOldFormat = oldDistanceData.some(d => d > 0);
             
             let datasets = [];
             
             if (hasNewFormat) {
                 if (misuData.some(d => d > 0)) {
                     datasets.push({
                         label: 'Misu',
                         data: misuData,
                         backgroundColor: distanceColors.misu,
                         borderColor: distanceColors.misu.replace('0.8', '1'),
                         borderWidth: 2
                     });
                 }
                 if (misaData.some(d => d > 0)) {
                     datasets.push({
                         label: 'Misa',
                         data: misaData,
                         backgroundColor: distanceColors.misa,
                         borderColor: distanceColors.misa.replace('0.8', '1'),
                         borderWidth: 2
                     });
                 }
             } else if (hasOldFormat) {
                 datasets.push({
                     label: 'Distance',
                     data: oldDistanceData,
                     backgroundColor: 'rgba(75, 192, 192, 0.8)',
                     borderColor: 'rgba(75, 192, 192, 1)',
                     borderWidth: 2
                 });
             }
             
             charts.distanceChart = new Chart(ctx, {
                 type: 'bar',
                 data: {
                     labels: labels,
                     datasets: datasets
                 },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     plugins: {
                         legend: {
                             display: true,
                             position: 'top'
                         },
                         tooltip: {
                             callbacks: {
                                 label: function(context) {
                                     return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + ' km';
                                 }
                             }
                         }
                     },
                     scales: {
                         y: {
                             beginAtZero: true,
                             title: {
                                 display: true,
                                 text: 'Kilom√®tres'
                             },
                             ticks: {
                                 stepSize: 1,
                                 callback: function(value) {
                                     return Math.round(value);
                                 }
                             }
                         }
                     }
                 }
             });
             
             // Ajouter l'√©v√©nement de clic sur tout l'encadr√© du graphique des distances
             const distanceContainer = document.getElementById('distanceChartContainer');
             if (distanceContainer) {
                 distanceContainer.addEventListener('click', function(evt) {
                     // Calculer les statistiques d√©taill√©es des distances
                     const distanceStats = {
                         misu: { total: 0, count: 0, avg: 0, min: Infinity, max: 0, dates: new Set() },
                         misa: { total: 0, count: 0, avg: 0, min: Infinity, max: 0, dates: new Set() },
                         old: { total: 0, count: 0, avg: 0, min: Infinity, max: 0, dates: new Set() },
                         combined: { total: 0, count: 0, avg: 0, min: Infinity, max: 0 }
                     };
                     
                     harvests.forEach(harvest => {
                         const misu = harvest.distanceMisu ? parseFloat(harvest.distanceMisu) : 0;
                         const misa = harvest.distanceMisa ? parseFloat(harvest.distanceMisa) : 0;
                         const old = harvest.distance ? parseFloat(harvest.distance) : 0;
                         
                         if (misu > 0) {
                             distanceStats.misu.total += misu;
                             distanceStats.misu.count += 1;
                             distanceStats.misu.min = Math.min(distanceStats.misu.min, misu);
                             distanceStats.misu.max = Math.max(distanceStats.misu.max, misu);
                             if (harvest.date) distanceStats.misu.dates.add(harvest.date);
                         }
                         
                         if (misa > 0) {
                             distanceStats.misa.total += misa;
                             distanceStats.misa.count += 1;
                             distanceStats.misa.min = Math.min(distanceStats.misa.min, misa);
                             distanceStats.misa.max = Math.max(distanceStats.misa.max, misa);
                             if (harvest.date) distanceStats.misa.dates.add(harvest.date);
                         }
                         
                         if (old > 0) {
                             distanceStats.old.total += old;
                             distanceStats.old.count += 1;
                             distanceStats.old.min = Math.min(distanceStats.old.min, old);
                             distanceStats.old.max = Math.max(distanceStats.old.max, old);
                             if (harvest.date) distanceStats.old.dates.add(harvest.date);
                         }
                         
                         const combined = Math.max(misu, misa, old);
                         if (combined > 0) {
                             distanceStats.combined.total += combined;
                             distanceStats.combined.count += 1;
                             distanceStats.combined.min = Math.min(distanceStats.combined.min, combined);
                             distanceStats.combined.max = Math.max(distanceStats.combined.max, combined);
                         }
                     });
                     
                     // Calculer les moyennes
                     if (distanceStats.misu.count > 0) distanceStats.misu.avg = distanceStats.misu.total / distanceStats.misu.count;
                     if (distanceStats.misa.count > 0) distanceStats.misa.avg = distanceStats.misa.total / distanceStats.misa.count;
                     if (distanceStats.old.count > 0) distanceStats.old.avg = distanceStats.old.total / distanceStats.old.count;
                     if (distanceStats.combined.count > 0) distanceStats.combined.avg = distanceStats.combined.total / distanceStats.combined.count;
                     
                     // Cr√©er un r√©sum√© sp√©cialis√© pour les distances
                     const summary = {
                         dateISO: new Date().toISOString().split('T')[0],
                         totalKg: harvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0),
                         count: getUniqueOutingsCount(harvests), // Utiliser la nouvelle logique
                         distinctVarieties: new Set(harvests.map(h => h.variety).filter(Boolean)).size,
                         timeMin: null,
                         timeMax: null,
                         weather: null,
                         byVariety: [],
                         byLocation: [],
                         distanceStats: {
                             misu: {
                                 total: distanceStats.misu.total.toFixed(1),
                                 count: distanceStats.misu.count,
                                 avg: distanceStats.misu.avg.toFixed(1),
                                 min: distanceStats.misu.min === Infinity ? 0 : distanceStats.misu.min.toFixed(1),
                                 max: distanceStats.misu.max.toFixed(1),
                                 dateCount: distanceStats.misu.dates.size
                             },
                             misa: {
                                 total: distanceStats.misa.total.toFixed(1),
                                 count: distanceStats.misa.count,
                                 avg: distanceStats.misa.avg.toFixed(1),
                                 min: distanceStats.misa.min === Infinity ? 0 : distanceStats.misa.min.toFixed(1),
                                 max: distanceStats.misa.max.toFixed(1),
                                 dateCount: distanceStats.misa.dates.size
                             },
                             combined: {
                                 total: distanceStats.combined.total.toFixed(1),
                                 count: distanceStats.combined.count,
                                 avg: distanceStats.combined.avg.toFixed(1),
                                 min: distanceStats.combined.min === Infinity ? 0 : distanceStats.combined.min.toFixed(1),
                                 max: distanceStats.combined.max.toFixed(1)
                             }
                         },
                         entries: harvests.map(h => ({
                             time: h.time || '',
                             variety: h.variety || '',
                             weightKg: parseFloat(h.weight) || 0,
                             location: h.location || '',
                             duration: h.duration || '',
                             distances: h.distanceMisu || h.distanceMisa || h.distance || '',
                             comment: h.comment || '',
                             photoUrl: h.photo || ''
                         }))
                     };
                     
                     showDayModal(summary);
                 });
             }
         }

        // Variables globales pour le calendrier multi-mois
        let selectedWeather = null;
        let selectedDate = null;
        let displayedMonths = [];
        
        // Variables pour les temp√©ratures
        let selectedTemperatureType = null; // 'mini' ou 'maxi'
        let selectedTemperatureValue = null;

        // Calendar functions
        function generateCalendar() {
            const monthsGrid = document.getElementById('monthsGrid');
            monthsGrid.innerHTML = '';
            
            // Charger les mois affich√©s depuis le localStorage
            loadDisplayedMonths();
            console.log('Mois charg√©s:', displayedMonths);
            
            // Trouver tous les mois qui ont des r√©coltes pour l'ann√©e s√©lectionn√©e
            const monthsWithHarvests = findMonthsWithHarvests(currentYear);
            console.log(`Mois avec r√©coltes pour ${currentYear}:`, monthsWithHarvests);
            
            // Ajouter automatiquement les mois avec r√©coltes qui ne sont pas encore affich√©s
            monthsWithHarvests.forEach(month => {
                const monthKey = `${month}-${currentYear}`;
                if (!displayedMonths.includes(monthKey)) {
                    console.log(`Ajout automatique du mois ${monthKey} car il a des r√©coltes`);
                    addMonthToDisplay(month, currentYear);
                }
            });
            
            // Filtrer pour ne montrer que les mois de l'ann√©e s√©lectionn√©e
            const currentYearMonths = displayedMonths.filter(monthKey => {
                const [month, year] = monthKey.split('-').map(Number);
                return year === currentYear;
            });
            
            console.log(`Mois de l'ann√©e ${currentYear} √† afficher:`, currentYearMonths);
            
            // Nettoyer automatiquement les mois vides seulement au chargement initial
            // Pas lors de l'ajout de nouveaux mois
            if (!window.calendarInitialized) {
                const initialCount = displayedMonths.length;
                displayedMonths = displayedMonths.filter(monthKey => {
                    const [month, year] = monthKey.split('-').map(Number);
                    const hasData = hasHarvestsInMonth(month, year);
                    if (!hasData) {
                        console.log(`Mois vide supprim√© au chargement: ${monthKey}`);
                    }
                    return hasData;
                });
                
                if (displayedMonths.length !== initialCount) {
                    console.log(`${initialCount - displayedMonths.length} mois vides supprim√©s au chargement`);
                    saveDisplayedMonths();
                }
                window.calendarInitialized = true;
            }
            
            // G√©n√©rer les cartes pour chaque mois de l'ann√©e s√©lectionn√©e
            currentYearMonths.forEach(monthKey => {
                const [month, year] = monthKey.split('-');
                const monthCard = createMonthCard(parseInt(month), parseInt(year));
                monthsGrid.appendChild(monthCard);
            });
            
            // Si aucun mois n'est affich√© pour l'ann√©e s√©lectionn√©e, afficher le mois actuel de cette ann√©e
            if (currentYearMonths.length === 0) {
                const currentDate = new Date();
                const currentMonth = currentDate.getMonth();
                const currentYearDate = currentDate.getFullYear();
                
                // Si l'ann√©e s√©lectionn√©e est l'ann√©e actuelle, utiliser le mois actuel
                if (currentYear === currentYearDate) {
                    addMonthToDisplay(currentMonth, currentYear);
                } else {
                    // Sinon, ajouter le premier mois de l'ann√©e s√©lectionn√©e
                    addMonthToDisplay(0, currentYear);
                }
            }
            
            // Initialiser la palette m√©t√©o
            initializeWeatherPalette();
            
            // Forcer la r√©initialisation apr√®s un d√©lai pour s'assurer que les √©l√©ments sont bien charg√©s
            setTimeout(() => {
                console.log('R√©initialisation forc√©e de la palette m√©t√©o');
                initializeWeatherPalette();
            }, 100);
        }

        function createMonthCard(month, year) {
            const monthCard = document.createElement('div');
            monthCard.className = 'month-card';
            
            const monthNames = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
                               'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
            
            const monthKey = `${month}-${year}`;
            
            monthCard.innerHTML = `
                <div class="month-header">
                    <h3 class="month-title">${monthNames[month]} ${year}</h3>
                </div>
                <div class="month-grid">
                    <div class="day-header">Lun</div>
                    <div class="day-header">Mar</div>
                    <div class="day-header">Mer</div>
                    <div class="day-header">Jeu</div>
                    <div class="day-header">Ven</div>
                    <div class="day-header">Sam</div>
                    <div class="day-header">Dim</div>
                    ${generateDaysForMonth(month, year)}
                </div>
            `;
            
            return monthCard;
        }

        function generateDaysForMonth(month, year) {
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            
            // Gestion sp√©ciale pour f√©vrier (ann√©es bissextiles)
            if (month === 1) { // F√©vrier
                const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
                const expectedDays = isLeapYear ? 29 : 28;
                if (daysInMonth !== expectedDays) {
                    console.warn(`Incoh√©rence d√©tect√©e pour f√©vrier ${year}: ${daysInMonth} jours au lieu de ${expectedDays}`);
                }
            }
            
            // Calculer le jour de la semaine du premier jour (0 = dimanche, 1 = lundi, etc.)
            let firstDayOfWeek = firstDay.getDay();
            if (firstDayOfWeek === 0) firstDayOfWeek = 7; // Convertir dimanche (0) en 7
            
            let html = '';
            
            // Ajouter les jours vides du mois pr√©c√©dent
            for (let i = 1; i < firstDayOfWeek; i++) {
                html += '<div class="day-cell other-month"></div>';
            }
            
            // Ajouter les jours du mois
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                // Utiliser le format local pour √©viter les probl√®mes de fuseau horaire
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayData = appData.years[year]?.calendar?.[dateStr] || {};
                
                                 const hasWeather = dayData.weather && dayData.weather !== 'clear';
                 const hasHarvest = dayData.hasHarvest;
                 
                 // D√©terminer le type de case pour l'affichage
                 let cellClass = 'day-cell';
                 let weatherTitle = '';
                 
                 if (hasWeather && hasHarvest) {
                     cellClass += ' has-both';
                     weatherTitle = 'Cliquer pour voir les d√©tails de la r√©colte';
                 } else if (hasWeather) {
                     cellClass += ' weather-only';
                     weatherTitle = 'Cliquer pour retirer la m√©t√©o';
                 } else if (hasHarvest) {
                     cellClass += ' harvest-only';
                 }
                 
                 // Affichage des temp√©ratures
                 const tempMini = dayData.temperatureMini;
                 const tempMaxi = dayData.temperatureMaxi;
                 let tempHtml = '';
                 
                 if (tempMini !== undefined && tempMini !== null) {
                     const tempClass = getTemperatureColorClass(tempMini);
                     tempHtml += `<div class="temperature-display temperature-mini ${tempClass}" onclick="handleTemperatureClick(event, '${dateStr}', 'mini')" title="Temp√©rature minimale: ${tempMini}¬∞C (cliquer pour supprimer)">${tempMini}</div>`;
                 }
                 
                 if (tempMaxi !== undefined && tempMaxi !== null) {
                     const tempClass = getTemperatureColorClass(tempMaxi);
                     tempHtml += `<div class="temperature-display temperature-maxi ${tempClass}" onclick="handleTemperatureClick(event, '${dateStr}', 'maxi')" title="Temp√©rature maximale: ${tempMaxi}¬∞C (cliquer pour supprimer)">${tempMaxi}</div>`;
                 }
                 
                 // Calcul du poids total pour ce jour
                 let weightHtml = '';
                 if (hasHarvest) {
                     const dayHarvests = appData.years[year]?.harvests?.filter(h => h.date === dateStr) || [];
                     const totalWeight = dayHarvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0);
                     if (totalWeight > 0) {
                         weightHtml = `<div class="weight-display" title="Poids total r√©colt√©: ${totalWeight.toFixed(1)} kg">${Math.round(totalWeight)}kg</div>`;
                     }
                 }
                 
                 html += `
                     <div class="${cellClass}" data-date="${dateStr}" onclick="handleDayClick('${dateStr}')">
                         <div class="day-number">${day}</div>
                         <div class="day-icons">
                             ${hasWeather ? `<div class="day-weather" onclick="handleWeatherClick(event, '${dateStr}')" title="${weatherTitle}">${getWeatherEmoji(dayData.weather)}</div>` : ''}
                             ${hasHarvest ? `<div class="day-harvest" onclick="handleHarvestClick(event, '${dateStr}')" title="Cliquer pour voir les d√©tails de la r√©colte">üçÑ</div>` : ''}
                         </div>
                         ${tempHtml}
                         ${weightHtml}
                     </div>
                 `;
            }
            
            // Ajouter les jours vides du mois suivant pour compl√©ter la grille
            const totalCells = 42; // 6 semaines * 7 jours
            const filledCells = firstDayOfWeek - 1 + daysInMonth;
            const remainingCells = totalCells - filledCells;
            
            for (let i = 0; i < remainingCells; i++) {
                html += '<div class="day-cell other-month"></div>';
            }
            
            return html;
        }

        function getWeatherEmoji(weather) {
            const emojis = {
                'sunny': '‚òÄÔ∏è',
                'cloud_sun': '‚õÖ',
                'cloudy': '‚òÅÔ∏è',
                'rainy': 'üåßÔ∏è',
                'thunderstorm': '‚õàÔ∏è',
                'lightning': '‚ö°',
                // compat backward: keep reading legacy key
                'sun_thunder': '‚õÖ‚ö°',
                'tornado': 'üå™Ô∏è',
                'foggy': 'üå´Ô∏è',
                'snowy': 'üå®Ô∏è',
                'clear': '‚ùå'
            };
            return emojis[weather] || '';
        }

        function getWeatherIcon(weather) {
            const icons = {
                'sunny': 'fa-sun text-yellow-500',
                'cloud_sun': 'fa-cloud-sun text-yellow-500',
                'cloudy': 'fa-cloud text-gray-500',
                'rainy': 'fa-cloud-rain text-blue-500',
                'thunderstorm': 'fa-bolt text-yellow-600',
                'lightning': 'fa-bolt text-yellow-600',
                // compat backward: keep reading legacy key
                'sun_thunder': 'fa-cloud-bolt text-yellow-600',
                'tornado': 'fa-wind text-red-500',
                'foggy': 'fa-smog text-gray-400',
                'snowy': 'fa-snowflake text-blue-300',
                'windy': 'fa-wind text-blue-300'
            };
            return icons[weather] || 'fa-question text-gray-500';
        }

        function getWeatherLabel(weather) {
            const labels = {
                'sunny': '‚òÄÔ∏è Ensoleill√©',
                'cloud_sun': '‚õÖ Nuage et soleil',
                'cloudy': '‚òÅÔ∏è Nuageux',
                'rainy': 'üåßÔ∏è Pluvieux',
                'thunderstorm': '‚õàÔ∏è Orage',
                'lightning': '‚ö° √âclair',
                'sun_thunder': '‚õÖ‚ö° √âclaircies orageuses',
                'tornado': 'üå™Ô∏è Tornade',
                'foggy': 'üå´Ô∏è Brouillard',
                'snowy': 'üå®Ô∏è Neige',
                'windy': 'üí® Venteux'
            };
            return labels[weather] || weather;
        }

        // Fonctions pour les temp√©ratures
        function getTemperatureColorClass(temperature) {
            const temp = parseInt(temperature);
            if (temp >= 0 && temp <= 10) return 'temperature-blue';
            if (temp >= 11 && temp <= 17) return 'temperature-green';
            if (temp >= 18 && temp <= 24) return 'temperature-orange';
            if (temp >= 25) return 'temperature-red';
            return 'temperature-blue'; // Par d√©faut pour les temp√©ratures n√©gatives
        }

        function selectTemperatureType(type) {
            const miniBtn = document.getElementById('tempMiniBtn');
            const maxiBtn = document.getElementById('tempMaxiBtn');
            const tempInput = document.getElementById('temperatureInput');
            
            // Si on clique sur le m√™me bouton actif, on d√©s√©lectionne
            if (selectedTemperatureType === type) {
                selectedTemperatureType = null;
                selectedTemperatureValue = null;
                miniBtn.classList.remove('active');
                maxiBtn.classList.remove('active');
                tempInput.value = '';
                console.log('Type de temp√©rature d√©s√©lectionn√©');
            } else {
                selectedTemperatureType = type;
                
                // Mettre √† jour l'√©tat actif des boutons
                miniBtn.classList.remove('active');
                maxiBtn.classList.remove('active');
                
                if (type === 'mini') {
                    miniBtn.classList.add('active');
                } else {
                    maxiBtn.classList.add('active');
                }
                
                console.log('Type de temp√©rature s√©lectionn√©:', type);
            }
        }

        function setTemperatureForDate(dateStr, type, value) {
            const year = new Date(dateStr).getFullYear();
            if (!appData.years[year]) {
                appData.years[year] = { harvests: [], calendar: {} };
            }
            if (!appData.years[year].calendar[dateStr]) {
                appData.years[year].calendar[dateStr] = {};
            }
            
            if (value !== null && value !== '') {
                appData.years[year].calendar[dateStr][`temperature${type.charAt(0).toUpperCase() + type.slice(1)}`] = parseInt(value);
                console.log(`Temp√©rature ${type} ${value}¬∞C ajout√©e pour ${dateStr}`);
            } else {
                // Supprimer la temp√©rature si la valeur est vide
                delete appData.years[year].calendar[dateStr][`temperature${type.charAt(0).toUpperCase() + type.slice(1)}`];
                console.log(`Temp√©rature ${type} supprim√©e pour ${dateStr}`);
            }
            
            saveData();
            generateCalendar();
        }

        function addMonth() {
            const monthNames = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
                               'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
            
            // Utiliser l'ann√©e actuellement s√©lectionn√©e dans le calendrier
            const year = currentYear;
            
            // Cr√©er un modal pour la s√©lection du mois
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            
            let monthOptions = '';
            monthNames.forEach((monthName, index) => {
                const monthKey = `${index}-${year}`;
                const isAlreadyDisplayed = displayedMonths.includes(monthKey);
                const disabledAttr = isAlreadyDisplayed ? 'disabled' : '';
                const disabledClass = isAlreadyDisplayed ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-100 cursor-pointer';
                
                monthOptions += `
                    <button class="month-option w-full p-3 text-left border-b ${disabledClass}" 
                            data-month="${index}" ${disabledAttr}>
                        ${monthName} ${year}
                        ${isAlreadyDisplayed ? '<span class="text-sm text-gray-500">(d√©j√† affich√©)</span>' : ''}
                    </button>
                `;
            });
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold" style="color: var(--mushroom-brown);">
                            <i class="fas fa-calendar-plus mr-2"></i>S√©lectionner un mois
                        </h3>
                        <button class="text-2xl" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="mb-4">
                        <p class="text-sm text-gray-600 mb-3">Ann√©e s√©lectionn√©e : <strong>${year}</strong></p>
                        <div class="grid grid-cols-1 gap-1">
                            ${monthOptions}
                        </div>
                    </div>
                    <div class="flex justify-end">
                        <button class="px-4 py-2 border rounded" onclick="this.closest('.modal').remove()">Annuler</button>
                    </div>
                </div>
            `;
            
            // Ajouter les √©v√©nements de clic sur les options
            modal.addEventListener('click', function(e) {
                if (e.target.classList.contains('month-option') && !e.target.hasAttribute('disabled')) {
                    const month = parseInt(e.target.dataset.month);
                    const monthKey = `${month}-${year}`;
                    
                    console.log('Ajout du mois:', monthKey);
                    addMonthToDisplay(month, year);
                    console.log('Mois apr√®s ajout:', displayedMonths);
                    
                    // Fermer le modal d'abord
                    modal.remove();
                    
                    // Puis r√©g√©n√©rer le calendrier
                    setTimeout(() => {
                        generateCalendar();
                    }, 50);
                }
            });
            
            // Fermer le modal en cliquant √† l'ext√©rieur
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            document.body.appendChild(modal);
        }



        function addMonthToDisplay(month, year) {
            const monthKey = `${month}-${year}`;
            if (!displayedMonths.includes(monthKey)) {
                displayedMonths.push(monthKey);
                // Trier par ordre chronologique
                displayedMonths.sort((a, b) => {
                    const [monthA, yearA] = a.split('-').map(Number);
                    const [monthB, yearB] = b.split('-').map(Number);
                    return yearA - yearB || monthA - monthB;
                });
                saveDisplayedMonths();
                console.log('Mois ajout√©:', monthKey, 'Liste mise √† jour:', displayedMonths);
            } else {
                console.log('Mois d√©j√† pr√©sent:', monthKey);
            }
        }



        function scrollToMonth(monthKey) {
            const monthCard = document.querySelector(`[data-month="${monthKey}"]`);
            if (monthCard) {
                monthCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                monthCard.style.animation = 'pulse 1s';
                setTimeout(() => {
                    monthCard.style.animation = '';
                }, 1000);
            }
        }

        function loadDisplayedMonths() {
            const saved = localStorage.getItem('displayedMonths');
            if (saved) {
                displayedMonths = JSON.parse(saved);
            }
        }

        function saveDisplayedMonths() {
            localStorage.setItem('displayedMonths', JSON.stringify(displayedMonths));
        }

        function initializeWeatherPalette() {
            const weatherBtns = document.querySelectorAll('.weather-btn');
            console.log('Initialisation palette m√©t√©o, boutons trouv√©s:', weatherBtns.length);
            
            weatherBtns.forEach(btn => {
                // Supprimer les anciens event listeners
                btn.removeEventListener('click', btn.weatherClickHandler);
                
                // Cr√©er un nouveau handler
                btn.weatherClickHandler = function() {
                    const weather = this.dataset.weather;
                    console.log('Bouton m√©t√©o cliqu√©:', weather);
                    
                    // Si on clique sur le m√™me bouton actif, on d√©s√©lectionne
                    if (selectedWeather === weather) {
                        selectedWeather = null;
                        this.classList.remove('active');
                        console.log('M√©t√©o d√©s√©lectionn√©e');
                    } else {
                        selectedWeather = weather;
                        
                        // Mettre √† jour l'√©tat actif
                        weatherBtns.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        console.log('M√©t√©o s√©lectionn√©e:', weather, 'Bouton actif:', this.classList.contains('active'));
                    }
                };
                
                // Ajouter le nouveau event listener
                btn.addEventListener('click', btn.weatherClickHandler);
            });
        }

        function handleDayClick(dateStr) {
            selectedDate = dateStr;
            
            if (selectedWeather) {
                console.log('Ajout de m√©t√©o:', selectedWeather, 'pour la date:', dateStr);
                setWeatherForDate(dateStr, selectedWeather);
                // R√©initialiser la s√©lection apr√®s utilisation
                selectedWeather = null;
                // Mettre √† jour l'√©tat actif des boutons
                document.querySelectorAll('.weather-btn').forEach(btn => btn.classList.remove('active'));
            } else if (selectedTemperatureType) {
                // Gestion des temp√©ratures
                const tempInput = document.getElementById('temperatureInput');
                const tempValue = tempInput.value.trim();
                
                if (tempValue === '') {
                    alert('Veuillez saisir une valeur de temp√©rature');
                    return;
                }
                
                const tempNum = parseInt(tempValue);
                if (isNaN(tempNum) || tempNum < -20 || tempNum > 50) {
                    alert('Veuillez saisir une temp√©rature valide entre -20¬∞C et 50¬∞C');
                    return;
                }
                
                console.log('Ajout de temp√©rature:', selectedTemperatureType, tempNum, 'pour la date:', dateStr);
                setTemperatureForDate(dateStr, selectedTemperatureType, tempNum);
                
                // R√©initialiser la s√©lection apr√®s utilisation
                selectedTemperatureType = null;
                selectedTemperatureValue = null;
                tempInput.value = '';
                document.getElementById('tempMiniBtn').classList.remove('active');
                document.getElementById('tempMaxiBtn').classList.remove('active');
            } else {
                // V√©rifier si le jour a des donn√©es (m√©t√©o, r√©colte ou temp√©rature)
                const year = new Date(dateStr).getFullYear();
                const dayData = appData.years[year]?.calendar?.[dateStr] || {};
                const hasWeather = dayData.weather && dayData.weather !== 'clear';
                const hasHarvest = dayData.hasHarvest;
                const hasTemperature = dayData.temperatureMini !== undefined || dayData.temperatureMaxi !== undefined;
                
                // Ne rien faire si le jour n'a aucune donn√©e
                if (hasWeather || hasHarvest || hasTemperature) {
                    showDayDetails(dateStr);
                }
                // Sinon, ne rien faire (jour vide)
            }
        }

        function handleWeatherClick(event, dateStr) {
            event.stopPropagation();
            
            // V√©rifier si ce jour a des r√©coltes
            const year = new Date(dateStr).getFullYear();
            const dayData = appData.years[year]?.calendar?.[dateStr] || {};
            const hasHarvest = dayData.hasHarvest;
            
            if (hasHarvest) {
                // Si le jour a des r√©coltes, ouvrir les d√©tails
                showDayDetails(dateStr);
            } else {
                // Si le jour n'a que de la m√©t√©o, permettre la suppression
                if (confirm('Voulez-vous retirer la m√©t√©o de ce jour ?')) {
                    setWeatherForDate(dateStr, null);
                }
            }
        }

        function handleHarvestClick(event, dateStr) {
            event.stopPropagation();
            showDayDetails(dateStr);
        }

        function handleTemperatureClick(event, dateStr, type) {
            event.stopPropagation();
            
            const year = new Date(dateStr).getFullYear();
            const dayData = appData.years[year]?.calendar?.[dateStr] || {};
            const currentTemp = dayData[`temperature${type.charAt(0).toUpperCase() + type.slice(1)}`];
            
            if (confirm(`Voulez-vous supprimer la temp√©rature ${type} (${currentTemp}¬∞C) de ce jour ?`)) {
                setTemperatureForDate(dateStr, type, null);
            }
        }

        function setWeatherForDate(dateStr, weather) {
            const year = new Date(dateStr).getFullYear();
            if (!appData.years[year]) {
                appData.years[year] = { harvests: [], calendar: {} };
            }
            if (!appData.years[year].calendar[dateStr]) {
                appData.years[year].calendar[dateStr] = {};
            }
            
            if (weather) {
                appData.years[year].calendar[dateStr].weather = weather;
                console.log(`M√©t√©o ${weather} ajout√©e pour ${dateStr}`);
                console.log('Donn√©es sauvegard√©es:', appData.years[year].calendar[dateStr]);
            } else {
                delete appData.years[year].calendar[dateStr].weather;
                console.log(`M√©t√©o supprim√©e pour ${dateStr}`);
            }
            
            saveData();
            console.log('Donn√©es sauvegard√©es dans localStorage');
            generateCalendar();
        }

        function showDayDetails(dateStr) {
            const year = new Date(dateStr).getFullYear();
            const dayData = appData.years[year]?.calendar?.[dateStr] || {};
            const harvests = appData.years[year]?.harvests?.filter(h => h.date === dateStr) || [];
            
            const summary = buildDaySummary(dateStr);
            
            // Ajouter les informations de temp√©rature au r√©sum√©
            if (dayData.temperatureMini !== undefined || dayData.temperatureMaxi !== undefined) {
                summary.temperatures = {
                    mini: dayData.temperatureMini,
                    maxi: dayData.temperatureMaxi
                };
            }
            
            showDayModal(summary);
        }

        // Fonction pour cr√©er automatiquement un mois lors de l'ajout d'une r√©colte
        function ensureMonthDisplayed(dateStr) {
            const date = new Date(dateStr);
            const month = date.getMonth();
            const year = date.getFullYear();
            const monthKey = `${month}-${year}`;
            
            if (!displayedMonths.includes(monthKey)) {
                addMonthToDisplay(month, year);
                generateCalendar();
            }
        }
        
        // Fonction pour s'assurer que toutes les r√©coltes existantes sont dans le calendrier
        function ensureAllHarvestsInCalendar() {
            // Parcourir toutes les ann√©es
            Object.keys(appData.years).forEach(year => {
                if (appData.years[year] && appData.years[year].harvests) {
                    appData.years[year].harvests.forEach(harvest => {
                        if (harvest.date) {
                            const dateStr = harvest.date;
                            const harvestYear = new Date(harvest.date).getFullYear();
                            
                            // S'assurer que l'ann√©e existe dans le calendrier
                            if (!appData.years[harvestYear].calendar[dateStr]) {
                                appData.years[harvestYear].calendar[dateStr] = {};
                            }
                            
                            // Marquer cette date comme ayant une r√©colte
                            appData.years[harvestYear].calendar[dateStr].hasHarvest = true;
                            
                            // Ajouter la m√©t√©o si elle existe
                            if (harvest.weather) {
                                appData.years[harvestYear].calendar[dateStr].weather = harvest.weather;
                            }
                        }
                    });
                }
            });
        }

        // Variables pour les photos de r√©colte
        let harvestPhotos = [];

        // Fonction pour g√©rer l'upload de photos de r√©colte
        function handleHarvestPhotoUpload(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                compressAndStoreImage(file, 40, (base64) => {
                    harvestPhotos.push(base64);
                    updateHarvestPhotosDisplay();
                });
            });
        }

        // Fonction pour mettre √† jour l'affichage des photos de r√©colte
        function updateHarvestPhotosDisplay() {
            const container = document.getElementById('harvestPhotos');
            container.innerHTML = '';
            
            harvestPhotos.forEach((photo, index) => {
                const photoDiv = document.createElement('div');
                photoDiv.className = 'relative';
                photoDiv.innerHTML = `
                    <img src="${photo}" class="w-full h-24 object-cover rounded" alt="Photo r√©colte">
                    <button class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 text-xs" 
                            onclick="removeHarvestPhoto(${index})" title="Supprimer">√ó</button>
                `;
                container.appendChild(photoDiv);
            });
        }

        // Fonction pour supprimer une photo de r√©colte
        function removeHarvestPhoto(index) {
            harvestPhotos.splice(index, 1);
            updateHarvestPhotosDisplay();
        }

        // Fonction pour nettoyer les mois vides (appel√©e apr√®s suppression de r√©coltes)
        function cleanEmptyMonths() {
            const initialCount = displayedMonths.length;
            displayedMonths = displayedMonths.filter(monthKey => {
                const [month, year] = monthKey.split('-').map(Number);
                return hasHarvestsInMonth(month, year);
            });
            
            if (displayedMonths.length !== initialCount) {
                console.log('Mois vides supprim√©s:', initialCount - displayedMonths.length);
                saveDisplayedMonths();
                generateCalendar();
            }
        }

        // Fonction pour trouver tous les mois qui ont des r√©coltes pour une ann√©e donn√©e
        function findMonthsWithHarvests(year) {
            const months = new Set();
            
            if (appData.years[year] && appData.years[year].harvests) {
                appData.years[year].harvests.forEach(harvest => {
                    if (harvest.date) {
                        const date = new Date(harvest.date);
                        const month = date.getMonth();
                        months.add(month);
                    }
                });
            }
            
            return Array.from(months).sort((a, b) => a - b);
        }

        // Fonction pour nettoyer les entr√©es orphelines du calendrier
        function cleanOrphanCalendarEntries() {
            // Parcourir toutes les ann√©es
            Object.keys(appData.years).forEach(year => {
                if (appData.years[year] && appData.years[year].calendar) {
                    const calendar = appData.years[year].calendar;
                    const harvests = appData.years[year].harvests || [];
                    
                    // V√©rifier chaque date du calendrier
                    Object.keys(calendar).forEach(dateStr => {
                        const hasHarvest = harvests.some(harvest => harvest.date === dateStr);
                        const hasWeather = calendar[dateStr].weather && calendar[dateStr].weather !== 'clear';
                        const hasTemperature = calendar[dateStr].temperatureMini !== undefined || calendar[dateStr].temperatureMaxi !== undefined;
                        
                        // Si la date a une entr√©e hasHarvest mais pas de r√©colte, la nettoyer
                        if (calendar[dateStr].hasHarvest && !hasHarvest) {
                            delete calendar[dateStr].hasHarvest;
                            console.log(`Entr√©e orpheline supprim√©e pour ${dateStr}`);
                        }
                        
                        // Si la date n'a plus ni r√©colte ni m√©t√©o ni temp√©rature, supprimer compl√®tement l'entr√©e
                        if (!hasHarvest && !hasWeather && !hasTemperature) {
                            delete calendar[dateStr];
                            console.log(`Entr√©e vide supprim√©e pour ${dateStr}`);
                        }
                    });
                }
            });
        }

        // Fonction pour v√©rifier si un mois a des donn√©es (r√©coltes, m√©t√©o ou temp√©ratures)
        function hasHarvestsInMonth(month, year) {
            console.log(`V√©rification du mois ${month}-${year}`);
            
            // V√©rifier les r√©coltes
            if (appData.years[year] && appData.years[year].harvests) {
                const harvests = appData.years[year].harvests;
                const hasHarvests = harvests.some(harvest => {
                    const harvestDate = new Date(harvest.date);
                    return harvestDate.getMonth() === month && harvestDate.getFullYear() === year;
                });
                if (hasHarvests) {
                    console.log(`Mois ${month}-${year} a des r√©coltes`);
                    return true;
                }
            }
            
            // V√©rifier la m√©t√©o et les temp√©ratures
            if (appData.years[year] && appData.years[year].calendar) {
                const calendar = appData.years[year].calendar;
                console.log('Calendrier pour cette ann√©e:', calendar);
                
                const hasData = Object.keys(calendar).some(dateStr => {
                    const date = new Date(dateStr);
                    const isSameMonth = date.getMonth() === month && date.getFullYear() === year;
                    const hasWeatherData = calendar[dateStr].weather && calendar[dateStr].weather !== 'clear';
                    const hasTemperatureData = calendar[dateStr].temperatureMini !== undefined || calendar[dateStr].temperatureMaxi !== undefined;
                    
                    console.log(`Date ${dateStr}: mois=${date.getMonth()}, ann√©e=${date.getFullYear()}, m√©t√©o=${calendar[dateStr].weather}, tempMini=${calendar[dateStr].temperatureMini}, tempMaxi=${calendar[dateStr].temperatureMaxi}, m√™meMois=${isSameMonth}, aM√©t√©o=${hasWeatherData}, aTemp=${hasTemperatureData}`);
                    
                    return isSameMonth && (hasWeatherData || hasTemperatureData);
                });
                
                if (hasData) {
                    console.log(`Mois ${month}-${year} a des donn√©es m√©t√©o ou temp√©ratures`);
                    return true;
                }
            }
            
            console.log(`Mois ${month}-${year} n'a pas de donn√©es`);
            return false;
        }

        // Harvest functions
        function addNewHarvest() {
            editingHarvestIndex = -1; // R√©initialiser l'√©tat d'√©dition
            document.getElementById('harvestForm').reset();
            populateHarvestForm();
            
            // R√©initialiser les photos
            harvestPhotos = [];
            updateHarvestPhotosDisplay();
            
            // Remettre le titre et le bouton par d√©faut
            const modalTitle = document.querySelector('#harvestModal h3');
            modalTitle.innerHTML = '<i class="fas fa-seedling mr-2"></i>D√©tails de la R√©colte';
            
            const submitButton = document.querySelector('#harvestForm button[type="submit"]');
            submitButton.innerHTML = '<i class="fas fa-save mr-2"></i>Enregistrer';
            
            document.getElementById('harvestModal').style.display = 'block';
        }

                 function populateHarvestForm() {
             const varietySelect = document.getElementById('harvestVariety');
             const locationSelect = document.getElementById('harvestLocation');
             
             if (!varietySelect || !locationSelect) return;
             
             // Clear existing options except first
             varietySelect.innerHTML = '<option value="">S√©lectionner...</option>';
             locationSelect.innerHTML = '<option value="">S√©lectionner...</option>';
             
             // Add predefined varieties
             appData.settings.varieties.forEach(variety => {
                 const option = document.createElement('option');
                 option.value = variety;
                 option.textContent = variety;
                 varietySelect.appendChild(option);
             });
             
                              // Add custom option
                 const customVariety = document.createElement('option');
                 customVariety.value = 'custom';
                 customVariety.textContent = 'Autre (saisir manuellement)';
                 varietySelect.appendChild(customVariety);
                 
                 // G√©rer la s√©lection de vari√©t√© personnalis√©e
                 varietySelect.addEventListener('change', function() {
                     if (this.value === 'custom') {
                         const customName = prompt('Entrez le nom de la vari√©t√©:');
                         if (customName && customName.trim()) {
                             const customOption = document.createElement('option');
                             customOption.value = customName.trim();
                             customOption.textContent = customName.trim();
                             varietySelect.insertBefore(customOption, customVariety);
                             varietySelect.value = customName.trim();
                         } else {
                             varietySelect.value = '';
                         }
                     }
                 });
             
             // Add predefined locations
             appData.settings.locations.forEach(location => {
                 const option = document.createElement('option');
                 option.value = location;
                 option.textContent = location;
                 locationSelect.appendChild(option);
             });
             
                              // Add custom option
                 const customLocation = document.createElement('option');
                 customLocation.value = 'custom';
                 customLocation.textContent = 'Autre (saisir manuellement)';
                 locationSelect.appendChild(customLocation);
                 
                 // G√©rer la s√©lection d'emplacement personnalis√©
                 locationSelect.addEventListener('change', function() {
                     if (this.value === 'custom') {
                         const customName = prompt('Entrez le nom de l\'emplacement:');
                         if (customName && customName.trim()) {
                             const customOption = document.createElement('option');
                             customOption.value = customName.trim();
                             customOption.textContent = customName.trim();
                             locationSelect.insertBefore(customOption, customLocation);
                             locationSelect.value = customName.trim();
                         } else {
                             locationSelect.value = '';
                         }
                     }
                 });
         }

        function populateHarvestsTable() {
            const tbody = document.getElementById('harvestsTableBody');
            const harvests = appData.years[currentYear]?.harvests || [];
            
            // Si un tri est actif, appliquer le tri
            let displayHarvests = harvests;
            if (sortColumn) {
                displayHarvests = [...harvests].sort((a, b) => {
                    let aValue, bValue;
                    
                    switch (sortColumn) {
                        case 'date':
                            aValue = new Date(a.date);
                            bValue = new Date(b.date);
                            break;
                        case 'time':
                            aValue = a.time || '';
                            bValue = b.time || '';
                            break;
                        case 'variety':
                            aValue = a.variety || '';
                            bValue = b.variety || '';
                            break;
                        case 'weight':
                            aValue = parseFloat(a.weight) || 0;
                            bValue = parseFloat(b.weight) || 0;
                            break;
                        case 'location':
                            aValue = a.location || '';
                            bValue = b.location || '';
                            break;
                        case 'duration':
                            aValue = parseFloat(a.duration) || 0;
                            bValue = parseFloat(b.duration) || 0;
                            break;
                        case 'distance':
                            const aDistance = (parseFloat(a.distanceMisu) || 0) + (parseFloat(a.distanceMisa) || 0) || parseFloat(a.distance) || 0;
                            const bDistance = (parseFloat(b.distanceMisu) || 0) + (parseFloat(b.distanceMisa) || 0) || parseFloat(b.distance) || 0;
                            aValue = aDistance;
                            bValue = bDistance;
                            break;
                        default:
                            return 0;
                    }
                    
                    if (typeof aValue === 'string' && typeof bValue === 'string') {
                        return sortDirection === 'asc' ? 
                            aValue.localeCompare(bValue, 'fr') : 
                            bValue.localeCompare(aValue, 'fr');
                    } else {
                        return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
                    }
                });
            }
            
            tbody.innerHTML = '';
            
            displayHarvests.forEach((harvest, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="p-3">
                        ${harvest.photos && harvest.photos.length > 0 ? 
                            `<img src="${harvest.photos[0]}" class="w-12 h-12 object-cover rounded cursor-pointer" 
                                  onclick="showPhotoViewer('${harvest.photos[0]}')" alt="Photo r√©colte">` : 
                            '<i class="fas fa-camera text-gray-400"></i>'}
                    </td>
                    <td class="p-3">${new Date(harvest.date).toLocaleDateString('fr-FR')}</td>
                    <td class="p-3">${harvest.time || '-'}</td>
                    <td class="p-3">${harvest.variety || '-'}</td>
                    <td class="p-3">${harvest.weight || '-'} kg</td>
                    <td class="p-3">${harvest.location || '-'}</td>
                    <td class="p-3">${harvest.duration ? harvest.duration + ' h' : '-'}</td>
                                         <td class="p-3">
                         ${harvest.distanceMisu || harvest.distanceMisa ? 
                             `${harvest.distanceMisu ? 'Misu: ' + harvest.distanceMisu + 'km' : ''}${harvest.distanceMisu && harvest.distanceMisa ? ' / ' : ''}${harvest.distanceMisa ? 'Misa: ' + harvest.distanceMisa + 'km' : ''}` : 
                             harvest.distance ? harvest.distance + ' km' : '-'}
                     </td>
                    <td class="p-3">${harvest.comments || '-'}</td>
                    <td class="p-3">
                        <button class="text-blue-600 hover:text-blue-800 mr-2" onclick="editHarvest(${harvests.indexOf(harvest)})">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="text-red-600 hover:text-red-800" onclick="deleteHarvest(${harvests.indexOf(harvest)})">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });
            
            // Mettre √† jour les ic√¥nes de tri si un tri est actif
            if (sortColumn) {
                updateSortIcons();
            }
        }

        function editHarvest(index) {
            editingHarvestIndex = index;
            const harvest = appData.years[currentYear].harvests[index];
            
            // G√©rer les vari√©t√©s et emplacements personnalis√©s AVANT de remplir le formulaire
            populateHarvestForm();
            
            // Si la vari√©t√© n'est pas dans la liste pr√©d√©finie, l'ajouter
            if (harvest.variety && !appData.settings.varieties.includes(harvest.variety)) {
                const varietySelect = document.getElementById('harvestVariety');
                const customOption = document.createElement('option');
                customOption.value = harvest.variety;
                customOption.textContent = harvest.variety;
                varietySelect.appendChild(customOption);
            }
            
            // Si l'emplacement n'est pas dans la liste pr√©d√©finie, l'ajouter
            if (harvest.location && !appData.settings.locations.includes(harvest.location)) {
                const locationSelect = document.getElementById('harvestLocation');
                const customOption = document.createElement('option');
                customOption.value = harvest.location;
                customOption.textContent = harvest.location;
                locationSelect.appendChild(customOption);
            }
            
            // Remplir le formulaire avec les donn√©es de la r√©colte APR√àS avoir pr√©par√© les listes
            document.getElementById('harvestDate').value = harvest.date;
            document.getElementById('harvestTime').value = harvest.time;
            document.getElementById('harvestVariety').value = harvest.variety;
            document.getElementById('harvestWeight').value = harvest.weight;
            document.getElementById('harvestLocation').value = harvest.location;
            document.getElementById('harvestDuration').value = harvest.duration;
            document.getElementById('harvestDistanceMisu').value = harvest.distanceMisu || '';
            document.getElementById('harvestDistanceMisa').value = harvest.distanceMisa || '';
            document.getElementById('harvestWeather').value = harvest.weather || '';
            document.getElementById('harvestComments').value = harvest.comments || '';
            
            // Changer le titre du modal
            const modalTitle = document.querySelector('#harvestModal h3');
            modalTitle.innerHTML = '<i class="fas fa-edit mr-2"></i>Modifier la R√©colte';
            
            // Changer le texte du bouton
            const submitButton = document.querySelector('#harvestForm button[type="submit"]');
            submitButton.innerHTML = '<i class="fas fa-save mr-2"></i>Mettre √† jour';
            
            // Charger les photos existantes
            harvestPhotos = harvest.photos ? [...harvest.photos] : [];
            updateHarvestPhotosDisplay();
            
            // Ouvrir le modal
            document.getElementById('harvestModal').style.display = 'block';
        }

        function deleteHarvest(index) {
            if (confirm('√ätes-vous s√ªr de vouloir supprimer cette r√©colte ?')) {
                const harvest = appData.years[currentYear].harvests[index];
                const dateStr = harvest.date;
                
                // Supprimer la r√©colte
                appData.years[currentYear].harvests.splice(index, 1);
                
                // V√©rifier s'il reste des r√©coltes pour cette date
                const remainingHarvests = appData.years[currentYear].harvests.filter(h => h.date === dateStr);
                if (remainingHarvests.length === 0) {
                    // Plus de r√©coltes pour cette date, retirer l'ic√¥ne champignon
                    if (appData.years[currentYear].calendar[dateStr]) {
                        delete appData.years[currentYear].calendar[dateStr].hasHarvest;
                        // Si plus de donn√©es pour cette date, supprimer compl√®tement l'entr√©e
                        if (!appData.years[currentYear].calendar[dateStr].weather) {
                            delete appData.years[currentYear].calendar[dateStr];
                        }
                    }
                }
                
                populateHarvestsTable();
                updateDashboard();
                cleanEmptyMonths(); // Nettoyer les mois vides apr√®s suppression
                saveData();
            }
        }

        function filterHarvests() {
            // TODO: Implement filter functionality
            console.log('Filter harvests');
        }

        function sortTable(column) {
            // Changer la direction si on clique sur la m√™me colonne
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            
            // Mettre √† jour les ic√¥nes de tri dans l'en-t√™te
            updateSortIcons();
            
            // Trier les r√©coltes
            const harvests = appData.years[currentYear]?.harvests || [];
            const sortedHarvests = [...harvests].sort((a, b) => {
                let aValue, bValue;
                
                switch (column) {
                    case 'date':
                        aValue = new Date(a.date);
                        bValue = new Date(b.date);
                        break;
                    case 'time':
                        aValue = a.time || '';
                        bValue = b.time || '';
                        break;
                    case 'variety':
                        aValue = a.variety || '';
                        bValue = b.variety || '';
                        break;
                    case 'weight':
                        aValue = parseFloat(a.weight) || 0;
                        bValue = parseFloat(b.weight) || 0;
                        break;
                    case 'location':
                        aValue = a.location || '';
                        bValue = b.location || '';
                        break;
                    case 'duration':
                        aValue = parseFloat(a.duration) || 0;
                        bValue = parseFloat(b.duration) || 0;
                        break;
                    case 'distance':
                        // Comparer les distances combin√©es (Misu + Misa ou ancien format)
                        const aDistance = (parseFloat(a.distanceMisu) || 0) + (parseFloat(a.distanceMisa) || 0) || parseFloat(a.distance) || 0;
                        const bDistance = (parseFloat(b.distanceMisu) || 0) + (parseFloat(b.distanceMisa) || 0) || parseFloat(b.distance) || 0;
                        aValue = aDistance;
                        bValue = bDistance;
                        break;
                    default:
                        return 0;
                }
                
                // Comparaison selon le type de valeur
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortDirection === 'asc' ? 
                        aValue.localeCompare(bValue, 'fr') : 
                        bValue.localeCompare(aValue, 'fr');
                } else {
                    return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
                }
            });
            
            // Mettre √† jour l'affichage avec les donn√©es tri√©es
            displaySortedHarvests(sortedHarvests);
        }
        
        function updateSortIcons() {
            // Supprimer toutes les ic√¥nes de tri existantes
            document.querySelectorAll('th i.fa-sort, th i.fa-sort-up, th i.fa-sort-down').forEach(icon => {
                icon.className = 'fas fa-sort';
            });
            
            // Ajouter l'ic√¥ne appropri√©e √† la colonne tri√©e
            const headerCell = document.querySelector(`th[onclick*="${sortColumn}"]`);
            if (headerCell) {
                const icon = headerCell.querySelector('i.fas');
                if (icon) {
                    icon.className = sortDirection === 'asc' ? 'fas fa-sort-up' : 'fas fa-sort-down';
                }
            }
        }
        
        function displaySortedHarvests(sortedHarvests) {
            const tbody = document.getElementById('harvestsTableBody');
            tbody.innerHTML = '';
            
            sortedHarvests.forEach((harvest, index) => {
                // Trouver l'index original dans le tableau non tri√© pour les actions
                const originalIndex = appData.years[currentYear].harvests.indexOf(harvest);
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td class="p-3">
                        ${harvest.photos && harvest.photos.length > 0 ? 
                            `<img src="${harvest.photos[0]}" class="w-12 h-12 object-cover rounded cursor-pointer" 
                                  onclick="showPhotoViewer('${harvest.photos[0]}')" alt="Photo r√©colte">` : 
                            '<i class="fas fa-camera text-gray-400"></i>'}
                    </td>
                    <td class="p-3">${new Date(harvest.date).toLocaleDateString('fr-FR')}</td>
                    <td class="p-3">${harvest.time || '-'}</td>
                    <td class="p-3">${harvest.variety || '-'}</td>
                    <td class="p-3">${harvest.weight || '-'} kg</td>
                    <td class="p-3">${harvest.location || '-'}</td>
                    <td class="p-3">${harvest.duration ? harvest.duration + ' h' : '-'}</td>
                    <td class="p-3">
                        ${harvest.distanceMisu || harvest.distanceMisa ? 
                            `${harvest.distanceMisu ? 'Misu: ' + harvest.distanceMisu + 'km' : ''}${harvest.distanceMisu && harvest.distanceMisa ? ' / ' : ''}${harvest.distanceMisa ? 'Misa: ' + harvest.distanceMisa + 'km' : ''}` : 
                            harvest.distance ? harvest.distance + ' km' : '-'}
                    </td>
                    <td class="p-3">${harvest.comments || '-'}</td>
                    <td class="p-3">
                        <button class="text-blue-600 hover:text-blue-800 mr-2" onclick="editHarvest(${originalIndex})">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="text-red-600 hover:text-red-800" onclick="deleteHarvest(${originalIndex})">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        // Settings functions
        function populateSettings() {
            populateVarietiesList();
            populateLocationsList();
            loadSettingsValues();
        }

        function populateVarietiesList() {
            const list = document.getElementById('varietiesList');
            list.innerHTML = '';
            
            appData.settings.varieties.forEach((variety, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-2 bg-gray-100 rounded';
                div.innerHTML = `
                    <span>${variety}</span>
                    <button class="text-red-600 hover:text-red-800" onclick="removeVariety(${index})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                list.appendChild(div);
            });
        }

        function populateLocationsList() {
            const list = document.getElementById('locationsList');
            list.innerHTML = '';
            
            appData.settings.locations.forEach((location, index) => {
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center p-2 bg-gray-100 rounded';
                div.innerHTML = `
                    <span>${location}</span>
                    <button class="text-red-600 hover:text-red-800" onclick="removeLocation(${index})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                list.appendChild(div);
            });
        }

        function loadSettingsValues() {
            document.getElementById('defaultWeightUnit').value = appData.settings.defaultWeightUnit;
            document.getElementById('dateFormat').value = appData.settings.dateFormat;
            document.getElementById('maxPhotoSize').value = appData.settings.maxPhotoSize;
            document.getElementById('autoBackup').checked = appData.settings.autoBackup;
        }

        function addVariety() {
            const input = document.getElementById('newVariety');
            const variety = input.value.trim();
            
            if (variety && !appData.settings.varieties.includes(variety)) {
                appData.settings.varieties.push(variety);
                populateVarietiesList();
                input.value = '';
                saveData();
            }
        }

        function removeVariety(index) {
            appData.settings.varieties.splice(index, 1);
            populateVarietiesList();
            saveData();
        }

        function addLocation() {
            const input = document.getElementById('newLocation');
            const location = input.value.trim();
            
            if (location && !appData.settings.locations.includes(location)) {
                appData.settings.locations.push(location);
                populateLocationsList();
                input.value = '';
                saveData();
            }
        }

        function removeLocation(index) {
            appData.settings.locations.splice(index, 1);
            populateLocationsList();
            saveData();
        }

        // Photo functions
        function uploadDashboardPhoto(index) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    // Demander une date (JJ/MM) optionnelle lors de l'upload
                    let dateInput = prompt('Date de la photo (JJ/MM) ‚Äî laissez vide pour plus tard :', '');
                    dateInput = (dateInput || '').trim();
                    const isValidDate = /^([0-2][0-9]|3[01])\/(0[1-9]|1[0-2])$/.test(dateInput);
                    if (dateInput && !isValidDate) {
                        alert('Format invalide. Utilisez JJ/MM, par ex. 15/09.');
                        dateInput = '';
                    }

                    compressAndStoreImage(file, 40, (base64) => {
                        // Initialiser l'ann√©e si elle n'existe pas
                        if (!appData.dashboardPhotos[currentYear]) {
                            appData.dashboardPhotos[currentYear] = ['', '', '', '', ''];
                        }
                        // Stocker sous forme d'objet { src, date }
                        appData.dashboardPhotos[currentYear][index] = dateInput
                            ? { src: base64, date: dateInput }
                            : { src: base64 };
                        loadDashboardPhotos();
                        saveData();
                    });
                }
            };
            input.click();
        }

                 function loadDashboardPhotos() {
             // Initialiser l'ann√©e si elle n'existe pas
             if (!appData.dashboardPhotos[currentYear]) {
                 appData.dashboardPhotos[currentYear] = ['', '', '', '', ''];
             }
             
             // Mettre √† jour l'indicateur d'ann√©e dans le titre de la galerie
             const currentYearPhotosEl = document.getElementById('currentYearPhotos');
             if (currentYearPhotosEl) {
                 currentYearPhotosEl.textContent = currentYear;
             }
             
             for (let i = 0; i < 5; i++) {
                const container = document.getElementById(`dashPhoto${i}`);
                const removeButton = document.getElementById(`removePhoto${i}`);
                
                if (!container) continue; // Skip if container doesn't exist
                
                const slot = appData.dashboardPhotos[currentYear][i];
                const hasPhoto = (typeof slot === 'string' && slot.trim() !== '') || (slot && typeof slot === 'object' && (slot.src || slot.url || slot.photo));
                if (hasPhoto) {
                    const src = typeof slot === 'string' ? slot : (slot.src || slot.url || slot.photo || '');
                    const label = (slot && typeof slot === 'object' && slot.date && String(slot.date).trim() !== '') ? slot.date : 'Date';
                    container.innerHTML = `
                        <div class="w-full h-full relative">
                            <img src="${src}" class="w-full h-full object-cover rounded" alt="Photo ${i+1}">
                            <div class="photo-date-badge" onclick="editDashboardPhotoDate(${i}); event.stopPropagation();">${label}</div>
                        </div>`;
                    if (removeButton) {
                        removeButton.style.display = 'block';
                    }
                } else {
                    container.innerHTML = `<i class="fas fa-camera text-3xl" style="color: var(--mushroom-brown);"></i>`;
                    if (removeButton) {
                        removeButton.style.display = 'none';
                    }
                }
            }
        }

        function editDashboardPhotoDate(index) {
            // S'assurer que la structure existe
            if (!appData.dashboardPhotos[currentYear]) {
                appData.dashboardPhotos[currentYear] = ['', '', '', '', ''];
            }
            const slot = appData.dashboardPhotos[currentYear][index];
            // √âditer uniquement s'il y a une photo
            const hasPhoto = (typeof slot === 'string' && slot.trim() !== '') || (slot && typeof slot === 'object' && (slot.src || slot.url || slot.photo));
            if (!hasPhoto) return;

            const currentLabel = (slot && typeof slot === 'object' && slot.date) ? slot.date : '';
            let newDate = prompt('Modifier la date (JJ/MM) ‚Äî laisser vide pour aucun libell√© :', currentLabel || '');
            if (newDate === null) return; // annul√©
            newDate = newDate.trim();
            const isValidDate = newDate === '' || /^([0-2][0-9]|3[01])\/(0[1-9]|1[0-2])$/.test(newDate);
            if (!isValidDate) {
                alert('Format invalide. Utilisez JJ/MM, par ex. 15/09.');
                return;
            }

            // Normaliser le slot en objet
            let src = '';
            if (typeof slot === 'string') {
                src = slot;
            } else if (slot && typeof slot === 'object') {
                src = slot.src || slot.url || slot.photo || '';
            }
            appData.dashboardPhotos[currentYear][index] = newDate ? { src, date: newDate } : { src };
            saveData();
            loadDashboardPhotos();
        }

        function removeDashboardPhoto(index) {
            // Initialiser l'ann√©e si elle n'existe pas
            if (!appData.dashboardPhotos[currentYear]) {
                appData.dashboardPhotos[currentYear] = ['', '', '', '', ''];
            }
            appData.dashboardPhotos[currentYear][index] = '';
            loadDashboardPhotos();
            saveData();
        }

        function compressAndStoreImage(file, maxSizeKB, callback) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            
            img.onload = function() {
                // Calculate new dimensions
                let { width, height } = img;
                const maxDimension = maxSizeKB === 15 ? 150 : 300;
                
                if (width > height) {
                    if (width > maxDimension) {
                        height = (height * maxDimension) / width;
                        width = maxDimension;
                    }
                } else {
                    if (height > maxDimension) {
                        width = (width * maxDimension) / height;
                        height = maxDimension;
                    }
                }
                
                canvas.width = width;
                canvas.height = height;
                
                ctx.drawImage(img, 0, 0, width, height);
                
                // Compress until size is acceptable
                let quality = 0.8;
                let base64 = canvas.toDataURL('image/jpeg', quality);
                
                while (base64.length > maxSizeKB * 1024 * 1.33 && quality > 0.1) {
                    quality -= 0.1;
                    base64 = canvas.toDataURL('image/jpeg', quality);
                }
                
                callback(base64);
            };
            
            img.src = URL.createObjectURL(file);
        }

        // Modal functions
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

                 function openChartDetails(chartType) {
             const modal = document.getElementById('chartModal');
             const title = document.getElementById('chartModalTitle');
             const content = document.getElementById('chartModalContent');
             
             // TODO: Implement detailed chart analysis
             if (chartType === 'weekly') {
                 title.innerHTML = '<i class="fas fa-chart-bar mr-2"></i>Analyse Hebdomadaire D√©taill√©e';
                 content.innerHTML = '<p>Analyse d√©taill√©e des r√©coltes par semaine √† impl√©menter...</p>';
             } else if (chartType === 'variety') {
                 title.innerHTML = '<i class="fas fa-chart-pie mr-2"></i>Analyse par Vari√©t√©s';
                 content.innerHTML = '<p>Analyse d√©taill√©e par vari√©t√©s √† impl√©menter...</p>';
             } else if (chartType === 'distance') {
                 title.innerHTML = '<i class="fas fa-route mr-2"></i>Analyse des Distances';
                 content.innerHTML = '<p>Analyse d√©taill√©e des distances parcourues par Misu et Misa √† impl√©menter...</p>';
             }
             
             modal.style.display = 'block';
         }

        // Import/Export functions
        function exportHarvestsJSON() {
            const data = {
                year: currentYear,
                harvests: appData.years[currentYear]?.harvests || [],
                exportDate: new Date().toISOString()
            };
            
            // Format de date pour le nom de fichier : aaaa-mm-jj
            const today = new Date();
            const dateStr = formatDateToISO(today); // Format YYYY-MM-DD
            
            downloadJSON(data, `champipote_${dateStr}.json`);
        }

        function exportAllData() {
            const data = {
                ...appData,
                exportDate: new Date().toISOString(),
                version: '1.1',
                // Inclure aussi les donn√©es auxiliaires persist√©es en dehors d'appData
                displayedMonths: Array.isArray(displayedMonths) ? [...displayedMonths] : [],
                customVarietyColors: { ...customVarietyColors }
            };
            
            // Format de date pour le nom de fichier : aaaa-mm-jj
            const today = new Date();
            const dateStr = formatDateToISO(today); // Format YYYY-MM-DD
            
            downloadJSON(data, `champipote_complet_${dateStr}.json`);
        }

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function triggerImport() {
            const input = document.getElementById('importFile');
            input.click();
        }

        function importData() {
            const input = document.getElementById('importFile');
            const file = input.files[0];
            
            if (!file) {
                alert('Veuillez s√©lectionner un fichier √† importer.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (confirm('Cette action remplacera les donn√©es existantes. √ätes-vous s√ªr ?')) {
                        // Fusionner les donn√©es import√©es avec migration si n√©cessaire
                        if (data.years) {
                            Object.assign(appData.years, data.years);
                        }
                        if (data.settings) {
                            Object.assign(appData.settings, data.settings);
                        }
                        // G√©rer dashboardPhotos: accept√© comme tableau (ancien), objet simple {year: [..]},
                        // ou objet avec slots { src, date }
                        if (data.dashboardPhotos) {
                            if (Array.isArray(data.dashboardPhotos)) {
                                // Ancien format: tableau global (migr√© vers ann√©e courante)
                                const y = new Date().getFullYear();
                                appData.dashboardPhotos[y] = data.dashboardPhotos.map(p =>
                                    typeof p === 'string' ? (p ? { src: p } : '') : p
                                );
                                while (appData.dashboardPhotos[y].length < 5) appData.dashboardPhotos[y].push('');
                                appData.dashboardPhotos[y] = appData.dashboardPhotos[y].slice(0, 5);
                            } else if (typeof data.dashboardPhotos === 'object') {
                                // Nouvelle structure possible: copier profond√©ment ann√©e par ann√©e
                                Object.keys(data.dashboardPhotos).forEach(y => {
                                    const arr = data.dashboardPhotos[y] || [];
                                    appData.dashboardPhotos[y] = arr.map(p =>
                                        typeof p === 'string' ? (p ? { src: p } : '') : p
                                    ).slice(0, 5);
                                    while (appData.dashboardPhotos[y].length < 5) appData.dashboardPhotos[y].push('');
                                });
                            }
                        }

                        // Charger couleurs personnalis√©es si pr√©sentes
                        if (data.customVarietyColors) {
                            try {
                                customVarietyColors = { ...customVarietyColors, ...data.customVarietyColors };
                                saveCustomColors();
                            } catch {}
                        }

                        // Charger la liste des mois affich√©s si pr√©sente
                        if (Array.isArray(data.displayedMonths)) {
                            displayedMonths = [...new Set([...(displayedMonths || []), ...data.displayedMonths])];
                            saveDisplayedMonths();
                        }
                        
                        saveData();
                        location.reload(); // Refresh to apply changes
                    }
                } catch (error) {
                    alert('Erreur lors de l\'importation : fichier invalide.');
                }
            };
            reader.readAsText(file);
        }

        function resetAllData() {
            // Premi√®re confirmation
            if (!confirm('‚ö†Ô∏è ATTENTION : Cette action va supprimer TOUTES les donn√©es du carnet de r√©coltes.\n\n√ätes-vous vraiment s√ªr de vouloir continuer ?')) {
                return;
            }
            
            // Deuxi√®me confirmation avec saisie de texte
            const confirmationText = prompt('Pour confirmer la suppression, tapez "SUPPRIMER" :');
            if (confirmationText !== 'SUPPRIMER') {
                alert('Suppression annul√©e.');
                return;
            }
            
            // R√©initialiser les donn√©es
            appData = {
                years: {},
                settings: {
                    varieties: ['C√®pes de Bordeaux', 'Girolles', 'Pieds de mouton', 'Chanterelles', 'Coulemelles', 'Bolet jaune', 'Morilles'],
                    locations: ['For√™t des Pins', 'Bois de Ch√™nes', 'Clairi√®re Sud', 'Sentier du Nord'],
                    defaultWeightUnit: 'kg',
                    dateFormat: 'DD/MM/YYYY',
                    maxPhotoSize: 15,
                    autoBackup: false
                },
                // Structure par ann√©e pour les 5 photos, avec slots objets { src, date? }
                dashboardPhotos: {}
            };
            // R√©initialiser les √©tats externes √† appData
            displayedMonths = [];
            saveDisplayedMonths();
            customVarietyColors = {};
            saveCustomColors();
            
            // Vider le localStorage
            localStorage.removeItem('mushroomHarvestData');
            localStorage.removeItem('customVarietyColors');
            customVarietyColors = {}; // R√©initialiser les couleurs personnalis√©es
            
            // R√©initialiser l'ann√©e courante
            currentYear = new Date().getFullYear();
            
            // Rafra√Æchir l'interface
            populateYearSelector();
            populateSettings();
            updateDashboard();
            populateHarvestsTable();
            generateCalendar();
            
            alert('‚úÖ Toutes les donn√©es ont √©t√© supprim√©es avec succ√®s.\n\nL\'application a √©t√© r√©initialis√©e aux param√®tres par d√©faut.');
        }

        // Data persistence
        function saveData() {
            try {
                localStorage.setItem('mushroomHarvestData', JSON.stringify(appData));
                saveCustomColors(); // Sauvegarder aussi les couleurs personnalis√©es
                console.log('Donn√©es sauvegard√©es avec succ√®s');
            } catch (error) {
                console.error('Erreur lors de la sauvegarde:', error);
                // Si le localStorage est plein, essayer de nettoyer et r√©essayer
                if (error.name === 'QuotaExceededError') {
                    try {
                        localStorage.clear();
                        localStorage.setItem('mushroomHarvestData', JSON.stringify(appData));
                        saveCustomColors();
                        console.log('Donn√©es sauvegard√©es apr√®s nettoyage du localStorage');
                    } catch (retryError) {
                        console.error('Impossible de sauvegarder m√™me apr√®s nettoyage:', retryError);
                    }
                }
            }
        }

        function loadData() {
            try {
                const saved = localStorage.getItem('mushroomHarvestData');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Fusionner les donn√©es de mani√®re s√©curis√©e
                    if (parsed.years) {
                        appData.years = { ...appData.years, ...parsed.years };
                        console.log('Donn√©es des ann√©es charg√©es:', appData.years);
                    }
                    if (parsed.settings) {
                        appData.settings = { ...appData.settings, ...parsed.settings };
                    }
                                         if (parsed.dashboardPhotos) {
                         // G√©rer la migration des anciennes photos (tableau) vers la nouvelle structure (objet par ann√©e)
                         if (Array.isArray(parsed.dashboardPhotos)) {
                             // Migration : convertir l'ancien tableau en structure par ann√©e
                             appData.dashboardPhotos = {};
                             // Placer les anciennes photos dans l'ann√©e actuelle
                             const currentYear = new Date().getFullYear();
                             appData.dashboardPhotos[currentYear] = [...parsed.dashboardPhotos];
                             while (appData.dashboardPhotos[currentYear].length < 5) {
                                 appData.dashboardPhotos[currentYear].push('');
                             }
                             appData.dashboardPhotos[currentYear] = appData.dashboardPhotos[currentYear].slice(0, 5);
                         } else {
                             // Nouvelle structure : objet avec photos par ann√©e
                             appData.dashboardPhotos = parsed.dashboardPhotos;
                         }
                     }
                    
                    // Nettoyer les anciennes vari√©t√©s obsol√®tes
                    cleanObsoleteVarieties();
                    
                    console.log('Donn√©es charg√©es avec succ√®s');
                } else {
                    console.log('Aucune donn√©e sauvegard√©e trouv√©e, utilisation des donn√©es par d√©faut');
                }
            } catch (error) {
                console.error('Erreur lors du chargement:', error);
                console.log('Utilisation des donn√©es par d√©faut');
            }
        }
        
        function cleanObsoleteVarieties() {
            // Supprimer "Trompettes de la mort" des vari√©t√©s pr√©d√©finies si elle existe
            const obsoleteVarieties = ['Trompettes de la mort'];
            obsoleteVarieties.forEach(variety => {
                const index = appData.settings.varieties.indexOf(variety);
                if (index > -1) {
                    appData.settings.varieties.splice(index, 1);
                    console.log(`Vari√©t√© obsol√®te supprim√©e: ${variety}`);
                }
            });
            
            // S'assurer que les nouvelles vari√©t√©s sont pr√©sentes
            const requiredVarieties = ['Chanterelles', 'Bolet jaune', 'Morilles'];
            requiredVarieties.forEach(variety => {
                if (!appData.settings.varieties.includes(variety)) {
                    appData.settings.varieties.push(variety);
                    console.log(`Nouvelle vari√©t√© ajout√©e: ${variety}`);
                }
            });
        }
        
        // Fonction utilitaire pour formater une date en YYYY-MM-DD
        function formatDateToISO(date) {
            if (typeof date === 'string') {
                return date; // Si c'est d√©j√† une cha√Æne au format YYYY-MM-DD
            }
            const d = new Date(date);
            return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        }

        // Fonction de test pour v√©rifier la fonctionnalit√© des photos par ann√©e
        function testYearPhotos() {
            console.log('=== Test des photos par ann√©e ===');
            console.log('Ann√©e actuelle:', currentYear);
            console.log('Photos par ann√©e:', appData.dashboardPhotos);
            console.log('Photos pour l\'ann√©e actuelle:', appData.dashboardPhotos[currentYear]);
            
            // Test de changement d'ann√©e
            const testYear = 2023;
            const originalYear = currentYear;
            
            console.log(`\n--- Test avec l'ann√©e ${testYear} ---`);
            currentYear = testYear;
            loadDashboardPhotos();
            console.log('Photos apr√®s changement d\'ann√©e:', appData.dashboardPhotos[currentYear]);
            
            // Restaurer l'ann√©e originale
            currentYear = originalYear;
            loadDashboardPhotos();
            console.log('\n=== Test termin√© ===');
        }

        // Fonction pour construire le r√©sum√© d'un jour
        function buildDaySummary(dateISO) {
            const year = new Date(dateISO).getFullYear();
            const yearData = appData.years[year] || { harvests: [] };
            const dayHarvests = yearData.harvests.filter(h => h.date === dateISO);
            
            if (dayHarvests.length === 0) {
                return { dateISO, isEmpty: true };
            }
            
            // Calculs de base
            const totalKg = dayHarvests.reduce((sum, h) => sum + (parseFloat(h.weight) || 0), 0);
            const distinctVarieties = [...new Set(dayHarvests.map(h => h.variety).filter(v => v))];
            
            // Calcul de la dur√©e totale et de la plage horaire am√©lior√©e
            let totalDuration = 0;
            let earliestTime = null;
            let latestTime = null;
            
            dayHarvests.forEach(h => {
                // Ajouter la dur√©e si disponible
                if (h.duration && parseFloat(h.duration) > 0) {
                    totalDuration += parseFloat(h.duration);
                }
                
                // Trouver l'heure d'arriv√©e la plus t√¥t
                if (h.time) {
                    if (!earliestTime || h.time < earliestTime) {
                        earliestTime = h.time;
                    }
                }
            });
            
            // Calculer l'heure de fin bas√©e sur l'heure d'arriv√©e + dur√©e
            if (earliestTime && totalDuration > 0) {
                const startTime = new Date(`2000-01-01T${earliestTime}:00`);
                const endTime = new Date(startTime.getTime() + (totalDuration * 60 * 60 * 1000)); // Convertir heures en millisecondes
                latestTime = endTime.toTimeString().slice(0, 5); // Format HH:MM
            } else {
                // Fallback : utiliser les heures de fin des r√©coltes
                const times = dayHarvests.map(h => h.time).filter(t => t).sort();
                latestTime = times.length > 0 ? times[times.length - 1] : null;
            }
            
            // M√©t√©o
            const weather = yearData.calendar?.[dateISO]?.weather || null;
            
            // Par vari√©t√© avec calcul du cumul annuel
            const byVariety = {};
            
            // Calculer le cumul pour chaque vari√©t√© de l'ann√©e enti√®re
            const yearHarvests = yearData.harvests || [];
            const varietyCumul = {};
            const varietyFirstHarvest = {};
            
            yearHarvests.forEach(h => {
                if (h.variety) {
                    if (!varietyCumul[h.variety]) {
                        varietyCumul[h.variety] = 0;
                        varietyFirstHarvest[h.variety] = h.date;
                    }
                    varietyCumul[h.variety] += parseFloat(h.weight) || 0;
                }
            });
            
            // Calculer les statistiques du jour
            dayHarvests.forEach(h => {
                if (h.variety) {
                    if (!byVariety[h.variety]) {
                        byVariety[h.variety] = { 
                            name: h.variety, 
                            kg: 0, 
                            count: 0,
                            cumul: 0,
                            isFirstHarvest: false
                        };
                    }
                    byVariety[h.variety].kg += parseFloat(h.weight) || 0;
                    byVariety[h.variety].count++;
                }
            });
            
            // Ajouter les informations de cumul et premi√®re r√©colte
            Object.keys(byVariety).forEach(variety => {
                byVariety[variety].cumul = varietyCumul[variety] || 0;
                byVariety[variety].isFirstHarvest = varietyFirstHarvest[variety] === dateISO;
            });
            
            // Par emplacement avec calcul du cumul annuel
            const byLocation = {};
            
            // Calculer le cumul pour chaque emplacement de l'ann√©e enti√®re
            const locationCumul = {};
            const locationFirstHarvest = {};
            
            yearHarvests.forEach(h => {
                if (h.location) {
                    if (!locationCumul[h.location]) {
                        locationCumul[h.location] = 0;
                        locationFirstHarvest[h.location] = h.date;
                    }
                    locationCumul[h.location] += parseFloat(h.weight) || 0;
                }
            });
            
            // Calculer les statistiques du jour
            dayHarvests.forEach(h => {
                if (h.location) {
                    if (!byLocation[h.location]) {
                        byLocation[h.location] = { 
                            name: h.location, 
                            kg: 0, 
                            count: 0,
                            cumul: 0,
                            isFirstHarvest: false
                        };
                    }
                    byLocation[h.location].kg += parseFloat(h.weight) || 0;
                    byLocation[h.location].count++;
                }
            });
            
            // Ajouter les informations de cumul et premi√®re r√©colte
            Object.keys(byLocation).forEach(location => {
                byLocation[location].cumul = locationCumul[location] || 0;
                byLocation[location].isFirstHarvest = locationFirstHarvest[location] === dateISO;
            });
            
            // Entr√©es d√©taill√©es
            const entries = dayHarvests.map(h => ({
                time: h.time || '-',
                variety: h.variety || '-',
                weightKg: parseFloat(h.weight) || 0,
                location: h.location || '-',
                duration: h.duration || '-',
                distances: h.distanceMisu || h.distanceMisa ? 
                    `${h.distanceMisu ? 'Misu: ' + h.distanceMisu + 'km' : ''}${h.distanceMisu && h.distanceMisa ? ' / ' : ''}${h.distanceMisa ? 'Misa: ' + h.distanceMisa + 'km' : ''}` : 
                    h.distance ? h.distance + ' km' : '-',
                comment: h.comments || '-',
                photoUrl: h.photos && h.photos.length > 0 ? h.photos[0] : null
            }));
            
            return {
                dateISO,
                totalKg,
                count: dayHarvests.length,
                distinctVarieties: distinctVarieties.length,
                totalDuration: totalDuration,
                timeMin: earliestTime,
                timeMax: latestTime,
                weather,
                byVariety: Object.values(byVariety).sort((a, b) => b.kg - a.kg),
                byLocation: Object.values(byLocation).sort((a, b) => b.kg - a.kg),
                entries
            };
                 }
         
         // Variables globales pour le modal des d√©tails du jour
         let currentDaySummary = null;
         
         // Fonction pour afficher le modal des d√©tails du jour
         function showDayModal(summary) {
             currentDaySummary = summary;
             const modal = document.getElementById('dayDetailsModal');
             const title = document.getElementById('dayDetailsTitle');
             const content = document.getElementById('dayDetailsContent');
             
             // Formater la date et adapter le titre selon le type de donn√©es
             const date = new Date(summary.dateISO);
             const dateStr = date.toLocaleDateString('fr-FR');
             
             // Si timeMin et timeMax sont null, c'est un bilan global
             if (summary.timeMin === null && summary.timeMax === null) {
                 title.textContent = `Bilan Global - Ann√©e ${currentYear}`;
             } else {
                 title.textContent = `D√©tails du ${dateStr}`;
             }
             
             if (summary.isEmpty) {
                 content.innerHTML = '<p class="text-center text-gray-500">Aucune r√©colte ce jour</p>';
             } else {
                 content.innerHTML = buildDayDetailsHTML(summary);
             }
             
             modal.style.display = 'block';
             
             // Focus trap
             const firstButton = modal.querySelector('button');
             if (firstButton) firstButton.focus();
             
             // Gestionnaire ESC
             const handleEsc = function(e) {
                 if (e.key === 'Escape') {
                     closeDayDetailsModal();
                     document.removeEventListener('keydown', handleEsc);
                 }
             };
             document.addEventListener('keydown', handleEsc);
         }
         
         // Fonction pour construire le HTML des d√©tails du jour
         function buildDayDetailsHTML(summary) {
             let html = '';
             
             // R√©sum√© du jour ou bilan global
             html += '<div class="mb-6">';
             if (summary.timeMin === null && summary.timeMax === null) {
                 html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">Bilan Global</h4>';
             } else {
                 html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">R√©sum√© du jour</h4>';
             }
             html += '<div class="grid grid-cols-2 md:grid-cols-4 gap-4">';
             html += `<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">${summary.totalKg.toFixed(1)} kg</div><div class="text-sm">Total r√©colt√©</div></div>`;
             
             // Afficher la dur√©e au lieu du nombre de r√©coltes
             if (summary.totalDuration && summary.totalDuration > 0) {
                 html += `<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">${summary.totalDuration.toFixed(1)}h</div><div class="text-sm">Dur√©e totale</div></div>`;
             } else {
                 html += `<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">${summary.count}</div><div class="text-sm">R√©coltes</div></div>`;
             }
             
             html += `<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">${summary.distinctVarieties}</div><div class="text-sm">Vari√©t√©s</div></div>`;
             
             // Affichage am√©lior√© de la plage horaire
             if (summary.timeMin && summary.timeMax) {
                 html += `<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">${summary.timeMin} - ${summary.timeMax}</div><div class="text-sm">Plage horaire</div></div>`;
             } else {
                 html += '<div class="text-center p-3 bg-gray-100 rounded"><div class="font-bold">-</div><div class="text-sm">Plage horaire</div></div>';
             }
             html += '</div>';
             
             if (summary.weather) {
                 html += `<div class="mt-3 p-3 bg-blue-50 rounded"><i class="fas ${getWeatherIcon(summary.weather)} mr-2"></i>M√©t√©o: ${getWeatherLabel(summary.weather)}</div>`;
             }
             
             // Affichage des temp√©ratures
             if (summary.temperatures) {
                 let tempInfo = '';
                 if (summary.temperatures.mini !== undefined) {
                     const tempClass = getTemperatureColorClass(summary.temperatures.mini);
                     tempInfo += `<span class="inline-block px-2 py-1 rounded text-white text-sm mr-2 ${tempClass}">Min: ${summary.temperatures.mini}¬∞C</span>`;
                 }
                 if (summary.temperatures.maxi !== undefined) {
                     const tempClass = getTemperatureColorClass(summary.temperatures.maxi);
                     tempInfo += `<span class="inline-block px-2 py-1 rounded text-white text-sm ${tempClass}">Max: ${summary.temperatures.maxi}¬∞C</span>`;
                 }
                 if (tempInfo) {
                     html += `<div class="mt-3 p-3 bg-gray-50 rounded"><i class="fas fa-thermometer-half mr-2"></i>Temp√©ratures: ${tempInfo}</div>`;
                 }
             }
             html += '</div>';
             
             // Top par vari√©t√© avec statistiques d√©taill√©es
             if (summary.byVariety.length > 0) {
                 html += '<div class="mb-6">';
                 html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">Top par vari√©t√©</h4>';
                 html += '<div class="overflow-x-auto">';
                 html += '<table class="w-full border-collapse">';
                 
                 // En-t√™te adaptatif selon les donn√©es disponibles
                 if (summary.byVariety[0].percentage) {
                     html += '<thead><tr><th class="p-2 text-left border">Vari√©t√©</th><th class="p-2 text-left border">Poids (kg)</th><th class="p-2 text-left border">%</th><th class="p-2 text-left border">Cumul de la vari√©t√© de l\'ann√©e</th><th class="p-2 text-left border">Moyenne</th><th class="p-2 text-left border">Min-Max</th><th class="p-2 text-left border">Lieux</th><th class="p-2 text-left border">Jours</th></tr></thead>';
                 } else {
                     html += '<thead><tr><th class="p-2 text-left border">Vari√©t√©</th><th class="p-2 text-left border">Poids (kg)</th><th class="p-2 text-left border">Cumul de la vari√©t√© de l\'ann√©e</th></tr></thead>';
                 }
                 
                 html += '<tbody>';
                 summary.byVariety.forEach(v => {
                     // D√©terminer l'affichage du cumul
                     let cumulDisplay = '';
                     if (v.isFirstHarvest) {
                         cumulDisplay = '<span class="text-green-600 font-semibold">Premi√®re r√©colte</span>';
                     } else {
                         cumulDisplay = `${v.cumul.toFixed(1)} kg`;
                     }
                     
                     if (v.percentage) {
                         html += `<tr><td class="p-2 border">${v.name}</td><td class="p-2 border">${v.kg.toFixed(1)}</td><td class="p-2 border">${v.percentage}%</td><td class="p-2 border">${cumulDisplay}</td><td class="p-2 border">${v.avgWeight ? v.avgWeight.toFixed(1) : '-'}</td><td class="p-2 border">${v.minWeight && v.maxWeight ? `${v.minWeight.toFixed(1)}-${v.maxWeight.toFixed(1)}` : '-'}</td><td class="p-2 border">${v.locationCount || '-'}</td><td class="p-2 border">${v.dateCount || '-'}</td></tr>`;
                     } else {
                         html += `<tr><td class="p-2 border">${v.name}</td><td class="p-2 border">${v.kg.toFixed(1)}</td><td class="p-2 border">${cumulDisplay}</td></tr>`;
                     }
                 });
                 html += '</tbody></table></div></div>';
             }
             
             // Statistiques des distances (si disponibles)
             if (summary.distanceStats) {
                 html += '<div class="mb-6">';
                 html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">Statistiques des distances</h4>';
                 
                 // Statistiques par personne
                 if (summary.distanceStats.misu.count > 0 || summary.distanceStats.misa.count > 0) {
                     html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">';
                     
                     if (summary.distanceStats.misu.count > 0) {
                         html += '<div class="p-4 bg-green-50 rounded border">';
                         html += '<h5 class="font-bold mb-2" style="color: var(--mushroom-brown);">Misu</h5>';
                         html += `<div class="text-sm"><strong>Total:</strong> ${summary.distanceStats.misu.total} km</div>`;
                         html += `<div class="text-sm"><strong>R√©coltes:</strong> ${summary.distanceStats.misu.count}</div>`;
                         html += `<div class="text-sm"><strong>Moyenne:</strong> ${summary.distanceStats.misu.avg} km</div>`;
                         html += `<div class="text-sm"><strong>Min-Max:</strong> ${summary.distanceStats.misu.min}-${summary.distanceStats.misu.max} km</div>`;
                         html += `<div class="text-sm"><strong>Jours:</strong> ${summary.distanceStats.misu.dateCount}</div>`;
                         html += '</div>';
                     }
                     
                     if (summary.distanceStats.misa.count > 0) {
                         html += '<div class="p-4 bg-pink-50 rounded border">';
                         html += '<h5 class="font-bold mb-2" style="color: var(--mushroom-brown);">Misa</h5>';
                         html += `<div class="text-sm"><strong>Total:</strong> ${summary.distanceStats.misa.total} km</div>`;
                         html += `<div class="text-sm"><strong>R√©coltes:</strong> ${summary.distanceStats.misa.count}</div>`;
                         html += `<div class="text-sm"><strong>Moyenne:</strong> ${summary.distanceStats.misa.avg} km</div>`;
                         html += `<div class="text-sm"><strong>Min-Max:</strong> ${summary.distanceStats.misa.min}-${summary.distanceStats.misa.max} km</div>`;
                         html += `<div class="text-sm"><strong>Jours:</strong> ${summary.distanceStats.misa.dateCount}</div>`;
                         html += '</div>';
                     }
                     
                     html += '</div>';
                 }
                 
                 // Statistiques combin√©es
                 if (summary.distanceStats.combined.count > 0) {
                     html += '<div class="p-4 bg-blue-50 rounded border">';
                     html += '<h5 class="font-bold mb-2" style="color: var(--mushroom-brown);">Statistiques combin√©es</h5>';
                     html += `<div class="text-sm"><strong>Total parcouru:</strong> ${summary.distanceStats.combined.total} km</div>`;
                     html += `<div class="text-sm"><strong>R√©coltes avec distance:</strong> ${summary.distanceStats.combined.count}</div>`;
                     html += `<div class="text-sm"><strong>Moyenne par sortie:</strong> ${summary.distanceStats.combined.avg} km</div>`;
                     html += `<div class="text-sm"><strong>Distance min-max:</strong> ${summary.distanceStats.combined.min}-${summary.distanceStats.combined.max} km</div>`;
                     html += '</div>';
                 }
                 
                 html += '</div>';
             }
             
             // Top par emplacement
             if (summary.byLocation.length > 0) {
                 html += '<div class="mb-6">';
                 html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">Top par emplacement</h4>';
                 html += '<div class="overflow-x-auto">';
                 html += '<table class="w-full border-collapse">';
                 html += '<thead><tr><th class="p-2 text-left border">Emplacement</th><th class="p-2 text-left border">Poids (kg)</th><th class="p-2 text-left border">Cumul de l\'emplacement de l\'ann√©e</th></tr></thead>';
                 html += '<tbody>';
                 summary.byLocation.forEach(l => {
                     // D√©terminer l'affichage du cumul
                     let cumulDisplay = '';
                     if (l.isFirstHarvest) {
                         cumulDisplay = '<span class="text-green-600 font-semibold">Premi√®re r√©colte</span>';
                     } else {
                         cumulDisplay = `${l.cumul.toFixed(1)} kg`;
                     }
                     
                     html += `<tr><td class="p-2 border">${l.name}</td><td class="p-2 border">${l.kg.toFixed(1)}</td><td class="p-2 border">${cumulDisplay}</td></tr>`;
                 });
                 html += '</tbody></table></div></div>';
             }
             
             // Liste des r√©coltes
             html += '<div class="mb-6">';
             html += '<h4 class="text-lg font-bold mb-3" style="color: var(--mushroom-brown);">Liste des r√©coltes</h4>';
             
             const maxEntries = 50;
             const entriesToShow = summary.entries.slice(0, maxEntries);
             const hasMore = summary.entries.length > maxEntries;
             
             html += '<div class="overflow-x-auto">';
             html += '<table class="w-full border-collapse text-sm">';
             html += '<thead><tr>';
             html += '<th class="p-2 text-left border">Heure</th>';
             html += '<th class="p-2 text-left border">Vari√©t√©</th>';
             html += '<th class="p-2 text-left border">Poids</th>';
             html += '<th class="p-2 text-left border">Emplacement</th>';
             html += '<th class="p-2 text-left border">Dur√©e</th>';
             html += '<th class="p-2 text-left border">Distances</th>';
             html += '<th class="p-2 text-left border">Photo</th>';
             html += '<th class="p-2 text-left border">Commentaire</th>';
             html += '</tr></thead>';
             html += '<tbody>';
             
             entriesToShow.forEach(entry => {
                 html += '<tr>';
                 html += `<td class="p-2 border">${entry.time}</td>`;
                 html += `<td class="p-2 border">${entry.variety}</td>`;
                 html += `<td class="p-2 border">${entry.weightKg.toFixed(1)} kg</td>`;
                 html += `<td class="p-2 border">${entry.location}</td>`;
                 html += `<td class="p-2 border">${entry.duration}</td>`;
                 html += `<td class="p-2 border">${entry.distances}</td>`;
                 
                 if (entry.photoUrl) {
                     html += `<td class="p-2 border"><img src="${entry.photoUrl}" class="w-12 h-12 object-cover rounded cursor-pointer" onclick="showPhotoViewer('${entry.photoUrl}')" alt="Photo"></td>`;
                 } else {
                     html += '<td class="p-2 border">-</td>';
                 }
                 
                 html += `<td class="p-2 border">${entry.comment}</td>`;
                 html += '</tr>';
             });
             
             html += '</tbody></table></div>';
             
             if (hasMore) {
                 html += `<div class="mt-3 text-center"><button class="mushroom-btn px-4 py-2 rounded" onclick="showAllEntries()">Afficher toutes les ${summary.entries.length} entr√©es</button></div>`;
             }
             
             html += '</div>';
             
             return html;
         }
         
         // Fonction pour fermer le modal des d√©tails du jour
         function closeDayDetailsModal() {
             const modal = document.getElementById('dayDetailsModal');
             modal.style.display = 'none';
             currentDaySummary = null;
         }
         
         // Fonction pour afficher toutes les entr√©es
         function showAllEntries() {
             if (!currentDaySummary) return;
             
             const content = document.getElementById('dayDetailsContent');
             content.innerHTML = buildDayDetailsHTML(currentDaySummary);
         }
         
         // Fonction pour afficher une photo en grand
         function showPhotoViewer(photoUrl) {
             // Cr√©er un modal simple pour la photo
             const viewer = document.createElement('div');
             viewer.className = 'modal';
             viewer.style.display = 'block';
             viewer.innerHTML = `
                 <div class="modal-content" style="max-width: 80%; max-height: 80%;">
                     <div class="flex justify-between items-center mb-4">
                         <h3 class="text-xl font-bold">Photo</h3>
                         <button class="text-2xl" onclick="this.closest('.modal').remove()">&times;</button>
                     </div>
                     <img src="${photoUrl}" class="w-full h-auto" alt="Photo r√©colte">
                 </div>
             `;
             
             viewer.addEventListener('click', function(e) {
                 if (e.target === viewer) {
                     viewer.remove();
                 }
             });
             
             document.body.appendChild(viewer);
         }
 
                   // Form submission
         document.addEventListener('DOMContentLoaded', function() {
             const harvestForm = document.getElementById('harvestForm');
             if (harvestForm) {
                 harvestForm.addEventListener('submit', function(e) {
                     e.preventDefault();
                     
                     const harvest = {
                         date: document.getElementById('harvestDate').value,
                         time: document.getElementById('harvestTime').value,
                         variety: document.getElementById('harvestVariety').value,
                         weight: document.getElementById('harvestWeight').value,
                         location: document.getElementById('harvestLocation').value,
                         duration: document.getElementById('harvestDuration').value,
                         distanceMisu: document.getElementById('harvestDistanceMisu').value,
                         distanceMisa: document.getElementById('harvestDistanceMisa').value,
                         weather: document.getElementById('harvestWeather').value,
                         comments: document.getElementById('harvestComments').value,
                         photos: [...harvestPhotos] // Copier les photos actuelles
                     };
                     
                     // Validate required fields (only Date, Variety and Weight are required)
                     if (!harvest.date || !harvest.variety || !harvest.weight) {
                         alert('Veuillez remplir les champs obligatoires : Date, Vari√©t√© et Poids.');
                         return;
                     }
                     
                     if (editingHarvestIndex >= 0) {
                         // Mode √©dition : mettre √† jour la r√©colte existante
                         const oldHarvest = appData.years[currentYear].harvests[editingHarvestIndex];
                         const oldDateStr = oldHarvest.date;
                         const oldYear = new Date(oldHarvest.date).getFullYear();
                         const newYear = new Date(harvest.date).getFullYear();
                         
                         // Nettoyer l'ancienne date du calendrier
                         if (appData.years[oldYear] && appData.years[oldYear].calendar && appData.years[oldYear].calendar[oldDateStr]) {
                             delete appData.years[oldYear].calendar[oldDateStr].hasHarvest;
                             // Si plus de donn√©es pour cette date, supprimer compl√®tement l'entr√©e
                             if (!appData.years[oldYear].calendar[oldDateStr].weather) {
                                 delete appData.years[oldYear].calendar[oldDateStr];
                             }
                         }
                         
                         // Si la date change d'ann√©e, d√©placer la r√©colte
                         if (oldYear !== newYear) {
                             // Supprimer de l'ancienne ann√©e
                             appData.years[oldYear].harvests.splice(editingHarvestIndex, 1);
                             
                             // Ajouter √† la nouvelle ann√©e
                             if (!appData.years[newYear]) {
                                 initializeYear(newYear);
                             }
                             appData.years[newYear].harvests.push(harvest);
                             
                             // Basculer l'UI sur la nouvelle ann√©e
                             currentYear = newYear;
                         } else {
                             // M√™me ann√©e, juste mettre √† jour la r√©colte
                             appData.years[currentYear].harvests[editingHarvestIndex] = harvest;
                         }
                         
                         editingHarvestIndex = -1; // R√©initialiser l'√©tat d'√©dition
                     } else {
                         // Mode ajout : ajouter une nouvelle r√©colte
                         const harvestYear = new Date(harvest.date).getFullYear();
                         if (!appData.years[harvestYear]) {
                             initializeYear(harvestYear);
                         }
                         appData.years[harvestYear].harvests.push(harvest);
                         
                         // Basculer l'UI sur l'ann√©e de la r√©colte
                         currentYear = harvestYear;
                     }

                     // Mettre √† jour le calendrier de la bonne ann√©e
                     const dateStr = harvest.date;
                     const harvestYear = new Date(harvest.date).getFullYear();
                     if (!appData.years[harvestYear].calendar[dateStr]) {
                         appData.years[harvestYear].calendar[dateStr] = {};
                     }
                     appData.years[harvestYear].calendar[dateStr].hasHarvest = true;
                     if (harvest.weather) {
                         appData.years[harvestYear].calendar[dateStr].weather = harvest.weather;
                     }

                     // Cr√©er automatiquement le mois dans le calendrier si n√©cessaire
                     ensureMonthDisplayed(dateStr);

                     // Nettoyer les mois vides apr√®s modification
                     cleanEmptyMonths();
                     
                     // Nettoyer les dates orphelines dans le calendrier
                     cleanOrphanCalendarEntries();
                     
                     // S'assurer que toutes les r√©coltes existantes sont dans le calendrier
                     ensureAllHarvestsInCalendar();

                     // Rafra√Æchir les s√©lecteurs et l'interface
                     populateYearSelector();
                     saveData();
                     closeModal('harvestModal');
                     updateDashboard();
                     populateHarvestsTable();
                     
                     // Toujours r√©g√©n√©rer le calendrier pour s'assurer qu'il est √† jour
                     generateCalendar();
                 });
             }
         });

        // Additional utility functions for future implementation
        function addWeatherToDay() {
            // TODO: Implement weather addition to calendar day
            console.log('Add weather to day');
        }

        function addHarvestToDay() {
            // TODO: Implement harvest addition from calendar
            console.log('Add harvest to day');
        }

                 // Settings change handlers
         document.addEventListener('DOMContentLoaded', function() {
             const defaultWeightUnit = document.getElementById('defaultWeightUnit');
             const dateFormat = document.getElementById('dateFormat');
             const maxPhotoSize = document.getElementById('maxPhotoSize');
             const autoBackup = document.getElementById('autoBackup');
             
             if (defaultWeightUnit) {
                 defaultWeightUnit.addEventListener('change', function() {
                     appData.settings.defaultWeightUnit = this.value;
                     saveData();
                 });
             }
             
             if (dateFormat) {
                 dateFormat.addEventListener('change', function() {
                     appData.settings.dateFormat = this.value;
                     saveData();
                 });
             }
             
             if (maxPhotoSize) {
                 maxPhotoSize.addEventListener('change', function() {
                     appData.settings.maxPhotoSize = parseInt(this.value);
                     saveData();
                 });
             }
             
             if (autoBackup) {
                 autoBackup.addEventListener('change', function() {
                     appData.settings.autoBackup = this.checked;
                     saveData();
                 });
             }
         });

        // Gestionnaire pour la touche Entr√©e dans le champ de temp√©rature
        document.addEventListener('DOMContentLoaded', function() {
            const tempInput = document.getElementById('temperatureInput');
            if (tempInput) {
                tempInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        if (selectedTemperatureType) {
                            // Simuler un clic sur un jour pour appliquer la temp√©rature
                            if (selectedDate) {
                                handleDayClick(selectedDate);
                            } else {
                                alert('Veuillez d\'abord cliquer sur un jour du calendrier');
                            }
                        } else {
                            alert('Veuillez d\'abord s√©lectionner Mini ou Maxi');
                        }
                    }
                });
            }
            
            // Gestionnaire pour l'import de fichier
            const importFile = document.getElementById('importFile');
            if (importFile) {
                importFile.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        importData();
                    }
                });
            }
        });

        // Close modals when clicking outside
        window.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });
    </script>
</body>
</html>
